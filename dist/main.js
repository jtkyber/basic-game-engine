/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/control/app.ts":
/*!****************************!*\
  !*** ./src/control/app.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   App: () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _model_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/scene */ \"./src/model/scene.ts\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _view_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view/renderer */ \"./src/view/renderer.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass App {\n    constructor(canvas) {\n        this.start = () => {\n            this.then = performance.now();\n            this.startTime = this.then;\n            this.run();\n            setInterval(() => {\n                document.getElementById('fps_counter').innerText = (~~(1000 / window.myLib.deltaTime)).toString();\n            }, 1000);\n        };\n        this.run = () => {\n            requestAnimationFrame(this.run);\n            this.now = performance.now();\n            window.myLib.deltaTime = this.now - this.then;\n            if (window.myLib.deltaTime > this.fpsInterval) {\n                this.then = this.now - (window.myLib.deltaTime % this.fpsInterval);\n                this.scene.update();\n                this.renderer.render(this.scene.get_renderables(), this.scene.camera.get_position());\n                const lastCamPosition = this.scene.camera.position;\n                const lastPlayerPosition = this.scene.player.position;\n                this.scene.lastPlayerPos = lastPlayerPosition;\n                this.scene.lastCamPosition = lastCamPosition;\n                this.scene.move_player_FB(this.moveVec[0]);\n                this.scene.move_player_LR(this.moveVec[1]);\n                // Get distance/direction moved vector from last frame\n                const moveDeltaVector = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_1__.vecA_minus_vecB)(this.scene.camera.position, lastCamPosition);\n                this.scene.moveDeltaVector = moveDeltaVector;\n                this.scene.playerMoving = false;\n                if (this.moveVec[0] !== 0 || this.moveVec[1] !== 0) {\n                    this.scene.playerMoving = true;\n                    this.scene.player.set_rotation(Math.atan2(moveDeltaVector[1], moveDeltaVector[0]) * (180 / Math.PI), 1);\n                }\n            }\n        };\n        this.canvas = canvas;\n        this.collisionDebug = false;\n        this.pointerLocked = false;\n        this.maxFramerate = 60;\n        this.fpsInterval = 1000 / this.maxFramerate; // ms per frame\n        this.renderer = new _view_renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer(this.canvas, this.collisionDebug);\n        this.scene = new _model_scene__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        document.addEventListener('keydown', e => this.handleKeyDown(e));\n        document.addEventListener('keyup', e => this.handleKeyUp(e));\n        document.addEventListener('mousemove', e => this.handleMouseMove(e));\n        document.addEventListener('mousedown', e => this.handleMouseDown(e));\n        this.canvas.addEventListener('wheel', e => this.handleScrollWheel(e), { passive: true });\n        document.addEventListener('pointerlockchange', () => {\n            if (document.pointerLockElement === canvas) {\n                this.pointerLocked = true;\n            }\n            else\n                this.pointerLocked = false;\n        }, false);\n        this.keysPressed = [];\n        this.moveVec = [0, 0];\n    }\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            window.myLib = window.myLib || {};\n            window.myLib.deltaTime = 0;\n            yield this.renderer.setupDevice();\n            yield this.renderer.initLights();\n            yield this.renderer.initialize();\n            const meshes = this.renderer.objectMeshes;\n            const playerMesh = meshes.filter(m => m.modelName === 'player')[0];\n            this.scene.set_meshes(meshes, playerMesh, this.renderer.lightMesh);\n        });\n    }\n    handleKeyDown(e) {\n        if (!this.pointerLocked)\n            return;\n        if (e.code === 'KeyW') {\n            this.moveVec[0] = 1;\n        }\n        else if (e.code === 'KeyS') {\n            this.moveVec[0] = -1;\n        }\n        if (e.code === 'KeyA') {\n            this.moveVec[1] = -1;\n        }\n        else if (e.code === 'KeyD') {\n            this.moveVec[1] = 1;\n        }\n    }\n    handleKeyUp(e) {\n        if (!this.pointerLocked)\n            return;\n        switch (e.code) {\n            case 'KeyW':\n                this.moveVec[0] = 0;\n                break;\n            case 'KeyS':\n                this.moveVec[0] = 0;\n                break;\n            case 'KeyA':\n                this.moveVec[1] = 0;\n                break;\n            case 'KeyD':\n                this.moveVec[1] = 0;\n                break;\n        }\n    }\n    handleMouseMove(e) {\n        if (!this.pointerLocked)\n            return;\n        this.scene.spin_player(-(e.movementX / 20), -(e.movementY / 20));\n    }\n    handleMouseDown(e) {\n        this.lockPointer();\n    }\n    handleScrollWheel(e) {\n        if (!this.pointerLocked)\n            return;\n        this.scene.camDistFromPlayer += e.deltaY / 500;\n    }\n    lockPointer() {\n        if (document.pointerLockElement !== this.canvas) {\n            this.canvas.requestPointerLock =\n                this.canvas.requestPointerLock ||\n                    //@ts-expect-error\n                    this.canvas.mozRequestPointerLock ||\n                    //@ts-expect-error\n                    this.canvas.webkitRequestPointerLock;\n            //@ts-expect-error\n            const promise = this.canvas.requestPointerLock({ unadjustedMovement: true });\n            //@ts-expect-error\n            if (!promise) {\n                console.log('Disabling mouse acceleration is not supported');\n                return this.canvas.requestPointerLock();\n            }\n            return (promise\n                //@ts-expect-error\n                .then(() => console.log('Pointer is locked'))\n                //@ts-expect-error\n                .catch(err => {\n                if (err.name === 'NotSupportedError') {\n                    return this.canvas.requestPointerLock();\n                }\n            }));\n        }\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/control/app.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _control_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control/app */ \"./src/control/app.ts\");\n\nif (!navigator.gpu)\n    throw new Error('WebGPU not supported on this browser');\nconst canvas = document.getElementById('canvas');\nconst app = new _control_app__WEBPACK_IMPORTED_MODULE_0__.App(canvas);\napp.initialize().then(app.start);\n\n\n//# sourceURL=webpack://basic_engine/./src/index.ts?");

/***/ }),

/***/ "./src/model/camera.ts":
/*!*****************************!*\
  !*** ./src/model/camera.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n\n\nclass Camera {\n    constructor(position, theta, phi) {\n        this.position = position;\n        this.eulers = [0, phi, theta];\n        this.forwards = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.forwardMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.rightMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n    }\n    update() {\n        if (this.position[2] < 0.1)\n            this.position[2] = 0.1;\n        this.forwards = [\n            Math.cos((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[2])) * Math.cos((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[1])),\n            Math.sin((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[2])) * Math.cos((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[1])),\n            Math.sin((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[1])),\n        ];\n        this.forwardMove = [Math.cos((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[2])), Math.sin((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[2])), 0];\n        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(this.forwards, [0, 0, 1]);\n        this.rightMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(this.forwardMove, [0, 0, 1]);\n        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(this.right, this.forwards);\n        const target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(this.position, this.forwards);\n        // Eye: Position of the camera\n        // Target: The point we're looking at\n        // Up: The vector we are considering \"up\" to be at\n        this.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.lookAt(this.position, target, this.up);\n    }\n    get_view() {\n        return this.view;\n    }\n    get_position() {\n        return this.position;\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/camera.ts?");

/***/ }),

/***/ "./src/model/car.ts":
/*!**************************!*\
  !*** ./src/model/car.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Car: () => (/* binding */ Car)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\n\nclass Car extends _model__WEBPACK_IMPORTED_MODULE_1__.Model {\n    constructor(position, eulers) {\n        super(position, eulers);\n    }\n    update() {\n        this.eulers[2] += 0.02 * window.myLib.deltaTime;\n        this.model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.create();\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.translation(this.position, this.model);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateX(this.model, (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[0]), this.model);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateY(this.model, (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[1]), this.model);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateZ(this.model, (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[2]), this.model);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/car.ts?");

/***/ }),

/***/ "./src/model/floor.ts":
/*!****************************!*\
  !*** ./src/model/floor.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Floor: () => (/* binding */ Floor)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\nclass Floor extends _model__WEBPACK_IMPORTED_MODULE_0__.Model {\n    constructor(position, eulers) {\n        super(position, eulers);\n    }\n    update() {\n        this.model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.translation(this.position, this.model);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/floor.ts?");

/***/ }),

/***/ "./src/model/house.ts":
/*!****************************!*\
  !*** ./src/model/house.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   House: () => (/* binding */ House)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\nclass House extends _model__WEBPACK_IMPORTED_MODULE_0__.Model {\n    constructor(position, eulers) {\n        super(position, eulers);\n    }\n    update() {\n        this.model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\n        // v: the vector you are translating by\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.translation(this.position, this.model);\n        // axis: the axis you are rotating around\n        // angleInRadians: The angle you are rotating by\n        // mat4.scale(this.model, [2, 2, 2], this.model);\n        // mat4.rotateX(this.model, degToRad(90), this.model);\n        // mat4.rotateY(this.model, degToRad(90), this.model);\n        // mat4.rotateZ(this.model, degToRad(this.eulers[2]), this.model);\n        // Need to translate before rotating in WebGPU\n        // even though logically it should be the other way around\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/house.ts?");

/***/ }),

/***/ "./src/model/model.ts":
/*!****************************!*\
  !*** ./src/model/model.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\nclass Model {\n    constructor(position, eulers) {\n        this.position = position;\n        // Angle of rotation on each axis (I think)\n        this.eulers = eulers;\n        this.gravitySpd = 0.01;\n        this.gravityInc = 0.005;\n        this.gravityAcc = 0.005;\n        this.moveVector = [0, 0, 0];\n    }\n    update() { }\n    get_model() {\n        return this.model;\n    }\n    set_rotation(rot, i) {\n        this.eulers[i] = rot;\n    }\n    reset_gravity() {\n        this.gravityAcc = 0.005;\n    }\n    apply_gravity() {\n        this.gravityAcc += this.gravityInc * window.myLib.deltaTime;\n        this.position[2] -= this.gravitySpd * this.gravityAcc * window.myLib.deltaTime;\n        if (this.position[2] < 0) {\n            this.position[2] = 0;\n            this.reset_gravity();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/model.ts?");

/***/ }),

/***/ "./src/model/player.ts":
/*!*****************************!*\
  !*** ./src/model/player.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\n\nclass Player extends _model__WEBPACK_IMPORTED_MODULE_1__.Model {\n    constructor(position, eulers) {\n        super(position, eulers);\n        this.moveSpeed = 0.005;\n    }\n    update() {\n        this.model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.create();\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.translation(this.position, this.model);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateZ(this.model, (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_0__.degToRad)(this.eulers[1]), this.model);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/player.ts?");

/***/ }),

/***/ "./src/model/scene.ts":
/*!****************************!*\
  !*** ./src/model/scene.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _objectList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objectList */ \"./src/objectList.ts\");\n/* harmony import */ var _utils_collisions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/collisions */ \"./src/utils/collisions.ts\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./camera */ \"./src/model/camera.ts\");\n\n\n\n\n\nclass Scene {\n    constructor() {\n        this.modelData = new Float32Array(16 * _objectList__WEBPACK_IMPORTED_MODULE_0__.objectCount);\n        this.lightData = [];\n        this.boundingBoxData = new Float32Array(16 * _objectList__WEBPACK_IMPORTED_MODULE_0__.boundingBoxCount);\n        this.camDistFromPlayer = 2.5;\n        this.camHeightAbovePlayer = 0.5;\n        this.playerMoving = false;\n        this.player = _objectList__WEBPACK_IMPORTED_MODULE_0__.objectList.player.models[0];\n        this.camera = new _camera__WEBPACK_IMPORTED_MODULE_3__.Camera([\n            this.player.position[0] - this.camDistFromPlayer,\n            this.player.position[1],\n            this.player.position[2] + this.camHeightAbovePlayer,\n        ], 0, 0);\n    }\n    set_meshes(meshes, playerMesh, lightMesh) {\n        this.meshes = meshes;\n        this.playerMesh = playerMesh;\n        this.lightMesh = lightMesh;\n    }\n    update() {\n        if (this.camDistFromPlayer < 1)\n            this.camDistFromPlayer = 1;\n        else if (this.camDistFromPlayer > 10)\n            this.camDistFromPlayer = 10;\n        const playerBoundingVerticesInitial = this.playerMesh.boundingBoxVerticesInitial;\n        const playerBoundingVerticesGrouped = this.playerMesh.boundingBoxVerticesGrouped;\n        this.player.apply_gravity();\n        this.player.update();\n        const playerTransform = new Float32Array(16);\n        for (let i = 0; i < 16; i++) {\n            playerTransform[i] = this.player.get_model().at(i);\n        }\n        let i = 0;\n        let b_index = 0;\n        let light_index = 0;\n        let offsetVec = [];\n        let collisionCount = 0;\n        let playerBoxZdeltas = [];\n        let counter = 0;\n        for (let n = 0; n < Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList).length; n++) {\n            const name = Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList)[n];\n            const object = _objectList__WEBPACK_IMPORTED_MODULE_0__.objectList[name];\n            for (let oIndex = 0; oIndex < object.models.length; oIndex++) {\n                const model = object.models[oIndex];\n                model.update();\n                let modelMatrix = model.get_model();\n                for (let j = 0; j < 16; j++) {\n                    this.modelData[16 * i + j] = modelMatrix.at(j);\n                    if (object.hasBoundingBox)\n                        this.boundingBoxData[16 * b_index + j] = modelMatrix.at(j);\n                }\n                if (object.hasLights) {\n                    const lights = this.lightMesh.lightPositions[name];\n                    for (let l = 0; l < lights.length; l++) {\n                        for (let j = 0; j < 16; j++) {\n                            this.lightData[16 * light_index + j] = modelMatrix.at(j);\n                        }\n                        light_index++;\n                    }\n                }\n                i++;\n                if (object.hasBoundingBox && name !== 'player') {\n                    const modelTransorm = this.boundingBoxData.slice(16 * b_index, 16 * b_index + 16);\n                    const modelVerticesInitial = this.meshes[n].boundingBoxVerticesInitial;\n                    const modelVerticesGrouped = this.meshes[n].boundingBoxVerticesGrouped;\n                    const collisionData = (0,_utils_collisions__WEBPACK_IMPORTED_MODULE_1__.player_object_collision)(playerBoundingVerticesInitial, playerBoundingVerticesGrouped, playerTransform, modelVerticesInitial, modelVerticesGrouped, modelTransorm);\n                    if (collisionData) {\n                        for (let k = 0; k < collisionData.length; k++) {\n                            counter++;\n                            if (this.playerMoving &&\n                                (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.dot)(this.moveDeltaVector, model.moveVector) >= 0 &&\n                                (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.dot)(this.moveDeltaVector, collisionData[k].planeNormal) <= 0) {\n                                // If moving towards the plane and object not moving toward player\n                                // Get vector offset along plane normal\n                                const offsetVecCur = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.num_vec_multiply)((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.dot)(this.moveDeltaVector, collisionData[k].planeNormal) / 1, collisionData[k].planeNormal);\n                                collisionCount++;\n                                offsetVec = offsetVecCur;\n                            }\n                            else if (this.playerMoving && (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.dot)(this.moveDeltaVector, model.moveVector) < 0) {\n                                // If player moving and object moving towards player\n                                const offsetVecCur = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.num_vec_multiply)((0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.dot)(this.moveDeltaVector, collisionData[k].planeNormal) / 1, collisionData[k].planeNormal);\n                                collisionCount++;\n                                offsetVec = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.vecAdd)(offsetVecCur, (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.num_vec_multiply)(-window.myLib.deltaTime, model.moveVector));\n                            }\n                            else if (!this.playerMoving) {\n                                // If player not moving and being pushed by object\n                                collisionCount++;\n                                offsetVec = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_2__.num_vec_multiply)(-window.myLib.deltaTime, model.moveVector);\n                            }\n                            // Include playerBoxZdelta even if vector is facing away from plane\n                            playerBoxZdeltas.push(collisionData[k].playerBoxZdelta);\n                        }\n                    }\n                    b_index++;\n                }\n            }\n        }\n        // Find max playerBoxZdelta from collisions that's within range\n        let maxStepUpHeight = 0;\n        const stepHeight = 0.25;\n        for (let j = 0; j < playerBoxZdeltas.length; j++) {\n            if (playerBoxZdeltas[j] > maxStepUpHeight && playerBoxZdeltas[j] < stepHeight) {\n                maxStepUpHeight = playerBoxZdeltas[j];\n            }\n        }\n        // Apply stepUp transformation\n        if (collisionCount === 1) {\n            const offsetVecMean = offsetVec;\n            if (playerBoxZdeltas[0] > 0 && playerBoxZdeltas[0] < stepHeight) {\n                this.player.position[2] += maxStepUpHeight;\n                this.player.reset_gravity();\n            }\n            else {\n                this.offset_player(offsetVecMean, -1);\n            }\n        }\n        else if (collisionCount > 1) {\n            if (playerBoxZdeltas[0] > 0 && playerBoxZdeltas[0] < stepHeight) {\n                this.player.position[2] += maxStepUpHeight;\n                this.player.reset_gravity();\n            }\n            else {\n                this.player.position[0] = this.lastPlayerPos[0];\n                this.player.position[1] = this.lastPlayerPos[1];\n                this.camera.position[0] = this.lastCamPosition[0];\n                this.camera.position[1] = this.lastCamPosition[1];\n            }\n        }\n        else if (playerBoxZdeltas.length && playerBoxZdeltas[0] > 0 && playerBoxZdeltas[0] < stepHeight) {\n            this.player.position[2] += maxStepUpHeight;\n            this.player.reset_gravity();\n        }\n        this.spin_player(0, 0);\n        this.player.update();\n        this.camera.update();\n    }\n    player_moving() {\n        return this.moveDeltaVector[0] !== 0 && this.moveDeltaVector[1] !== 0 && this.moveDeltaVector[2] !== 0;\n    }\n    get_player() {\n        return this.camera;\n    }\n    get_renderables() {\n        return {\n            viewTransform: this.camera.get_view(),\n            modelTransforms: this.modelData,\n            boundingBoxTransforms: this.boundingBoxData,\n            lightTransforms: new Float32Array(this.lightData),\n        };\n    }\n    spin_player(dX, dY) {\n        // Camera\n        // Translate to center eye level of player\n        this.camera.position = [\n            this.player.position[0],\n            this.player.position[1],\n            this.player.position[2] + this.camHeightAbovePlayer,\n        ];\n        // Apply rotations\n        this.camera.eulers[2] += dX;\n        this.camera.eulers[2] %= 360;\n        this.camera.eulers[1] = Math.min(89, Math.max(-89, this.camera.eulers[1] + dY));\n        // Translate straight back along the forwards vector to the camera\n        this.camera.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.camera.position, this.camera.forwards, -this.camDistFromPlayer);\n    }\n    offset_player(dir, amt) {\n        // Camera\n        this.camera.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.camera.position, [dir[0], dir[1], 0], amt);\n        // Player\n        this.player.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.player.position, [dir[0], dir[1], 0], amt);\n    }\n    move_player_FB(dir) {\n        const moveAmt = dir * this.player.moveSpeed * window.myLib.deltaTime;\n        // Camera\n        this.camera.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.camera.position, \n        // Only move the camera along the xy plane (no verticle)\n        this.camera.forwardMove, moveAmt);\n        // Player\n        this.player.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.player.position, this.camera.forwardMove, moveAmt);\n    }\n    move_player_LR(dir) {\n        const moveAmt = dir * this.player.moveSpeed * window.myLib.deltaTime;\n        // Camera\n        this.camera.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.camera.position, \n        // Only move the camera along the xy plane (no verticle)\n        this.camera.rightMove, moveAmt);\n        // Player\n        this.player.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.addScaled(this.player.position, this.camera.rightMove, moveAmt);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/scene.ts?");

/***/ }),

/***/ "./src/model/tree.ts":
/*!***************************!*\
  !*** ./src/model/tree.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tree: () => (/* binding */ Tree)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\nclass Tree extends _model__WEBPACK_IMPORTED_MODULE_0__.Model {\n    constructor(position, eulers) {\n        super(position, eulers);\n    }\n    update() {\n        this.model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.translation(this.position, this.model);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/model/tree.ts?");

/***/ }),

/***/ "./src/objectList.ts":
/*!***************************!*\
  !*** ./src/objectList.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boundingBoxCount: () => (/* binding */ boundingBoxCount),\n/* harmony export */   objectCount: () => (/* binding */ objectCount),\n/* harmony export */   objectList: () => (/* binding */ objectList)\n/* harmony export */ });\n/* harmony import */ var _model_car__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/car */ \"./src/model/car.ts\");\n/* harmony import */ var _model_floor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/floor */ \"./src/model/floor.ts\");\n/* harmony import */ var _model_house__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/house */ \"./src/model/house.ts\");\n/* harmony import */ var _model_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/player */ \"./src/model/player.ts\");\n/* harmony import */ var _model_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/tree */ \"./src/model/tree.ts\");\n\n\n\n\n\nconst objectList = {\n    player: {\n        models: [new _model_player__WEBPACK_IMPORTED_MODULE_3__.Player([0, 0, 10], [0, 0, 0])],\n        hasBoundingBox: true,\n        hasLights: false,\n    },\n    house: {\n        models: [new _model_house__WEBPACK_IMPORTED_MODULE_2__.House([13, -10, 0], [0, 0, 0])],\n        hasBoundingBox: true,\n        hasLights: true,\n    },\n    tree: {\n        models: [new _model_tree__WEBPACK_IMPORTED_MODULE_4__.Tree([10, 2, 0], [90, 0, 0]), new _model_tree__WEBPACK_IMPORTED_MODULE_4__.Tree([10, 6, 0], [90, 0, 0])],\n        hasBoundingBox: true,\n        hasLights: false,\n    },\n    floor: {\n        models: [new _model_floor__WEBPACK_IMPORTED_MODULE_1__.Floor([0, 0, 0], [0, 0, 0])],\n        hasBoundingBox: false,\n        hasLights: false,\n    },\n    car: {\n        models: [new _model_car__WEBPACK_IMPORTED_MODULE_0__.Car([-2, -4, 0], [0, 0, -45])],\n        hasBoundingBox: false,\n        hasLights: false,\n    },\n};\nconst objectCount = Object.keys(objectList).reduce((acc, name) => {\n    return acc + objectList[name].models.length;\n}, 0);\nconst boundingBoxCount = Object.keys(objectList).reduce((acc, name) => {\n    if (objectList[name].hasBoundingBox)\n        return acc + objectList[name].models.length;\n    return acc;\n}, 0);\n\n\n//# sourceURL=webpack://basic_engine/./src/objectList.ts?");

/***/ }),

/***/ "./src/utils/collisions.ts":
/*!*********************************!*\
  !*** ./src/utils/collisions.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   player_object_collision: () => (/* binding */ player_object_collision)\n/* harmony export */ });\n/* harmony import */ var _math_stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _matrices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrices */ \"./src/utils/matrices.ts\");\n\n\nfunction get_cuboid_center(vertices) {\n    let sum = [0, 0, 0];\n    for (let i = 0; i < vertices.length; i += 3) {\n        sum[0] += vertices[i];\n        sum[1] += vertices[i + 1];\n        sum[2] += vertices[i + 2];\n    }\n    return [sum[0] / 8, sum[1] / 8, sum[2] / 8];\n}\nfunction get_transformed_cuboid_vertices(vertices, modelTransform) {\n    const newArr = [];\n    for (let i = 0; i < vertices.length; i += 3) {\n        newArr.push(...(0,_matrices__WEBPACK_IMPORTED_MODULE_1__.one_four_by_four_four)(vertices.slice(i, i + 3), modelTransform));\n    }\n    return new Float32Array(newArr);\n}\nfunction line_plane_collision_test(center, objVertices1, objVertices2) {\n    // Check objVertices1 diagonals against objVertices2 planes\n    for (let i = 0; i < objVertices1.length; i += 3) {\n        // Interate diagonals\n        const diagVertex = [objVertices1[i], objVertices1[i + 1], objVertices1[i + 2]];\n        // Ray vector\n        const diagVector = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(diagVertex, center);\n        for (let j = 0; j < objVertices2.length; j += 12) {\n            // Iterate planes\n            // Only need 3 verts (v1/v2/v3) to calculate plane normal\n            const v1 = [objVertices2[j], objVertices2[j + 1], objVertices2[j + 2]];\n            const v2 = [objVertices2[j + 3], objVertices2[j + 4], objVertices2[j + 5]];\n            const v3 = [objVertices2[j + 6], objVertices2[j + 7], objVertices2[j + 8]];\n            const v4 = [objVertices2[j + 9], objVertices2[j + 10], objVertices2[j + 11]];\n            // Plane normal (d = scaler)\n            const nA = v1[1] * (v2[2] - v3[2]) + v2[1] * (v3[2] - v1[2]) + v3[1] * (v1[2] - v2[2]);\n            const nB = v1[2] * (v2[0] - v3[0]) + v2[2] * (v3[0] - v1[0]) + v3[2] * (v1[0] - v2[0]);\n            const nC = v1[0] * (v2[1] - v3[1]) + v2[0] * (v3[1] - v1[1]) + v3[0] * (v1[1] - v2[1]);\n            const d = -v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) -\n                v2[0] * (v3[1] * v1[2] - v1[1] * v3[2]) -\n                v3[0] * (v1[1] * v2[2] - v2[1] * v1[2]);\n            // Plane intersection equation\n            const tNumer = nA * center[0] + nB * center[1] + nC * center[2] + d;\n            const tDenom = nA * diagVector[0] + nB * diagVector[1] + nC * diagVector[2];\n            const t = -tNumer / tDenom;\n            if (t >= 0 && t <= 1) {\n                const intersection = [\n                    center[0] + diagVector[0] * t,\n                    center[1] + diagVector[1] * t,\n                    center[2] + diagVector[2] * t,\n                ];\n                const vec1N = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v1, v2));\n                const vec2N = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v4, v1));\n                const vec3N = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v3, v4));\n                const vec4N = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v2, v3));\n                const intersectionN1 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v2, intersection));\n                const intersectionN2 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v1, intersection));\n                const intersectionN3 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v4, intersection));\n                const intersectionN4 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.vecA_minus_vecB)(v3, intersection));\n                const dot1 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.dot)(intersectionN1, vec1N);\n                const dot2 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.dot)(intersectionN2, vec2N);\n                const dot3 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.dot)(intersectionN3, vec3N);\n                const dot4 = (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.dot)(intersectionN4, vec4N);\n                if (dot1 <= 0 && dot2 <= 0 && dot3 <= 0 && dot4 <= 0)\n                    return (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.normalize)([nA, nB, nC]);\n            }\n        }\n    }\n    return false;\n}\nfunction player_object_collision(pVertices, pVerticesGrouped, playerTransform, modelVertices, modelVerticesGrouped, modelTransform) {\n    const transformedPvertices = get_transformed_cuboid_vertices(pVertices, playerTransform);\n    const transformedPverticesGrouped = get_transformed_cuboid_vertices(pVerticesGrouped, playerTransform);\n    const playerCenter = get_cuboid_center(transformedPvertices);\n    let playerZBottom = Infinity;\n    for (let j = 0; j < transformedPvertices.length; j += 3) {\n        if (transformedPvertices[j + 2] < playerZBottom)\n            playerZBottom = transformedPvertices[j + 2];\n    }\n    const collisionData = [];\n    let g_index = 0;\n    for (let i = 0; i < modelVertices.length; i += 24) {\n        let boxZTop = 0;\n        // Check each bounding box for current model\n        const transformedMvertices = get_transformed_cuboid_vertices(modelVertices.slice(i, i + 24), modelTransform);\n        // Grouped vertices 3 times as many vertices\n        const transformedMverticesGrouped = get_transformed_cuboid_vertices(modelVerticesGrouped.slice(g_index, g_index + 24 * 3), modelTransform);\n        const modelCenter = get_cuboid_center(transformedMvertices);\n        // Just need to now check intersection of player diagonals from center\n        // against other object's planes, and vice versa\n        const objectPlaneNormal = line_plane_collision_test(playerCenter, transformedPvertices, transformedMverticesGrouped);\n        if (objectPlaneNormal) {\n            for (let j = 0; j < transformedMvertices.length; j += 3) {\n                if (transformedMvertices[j + 2] > boxZTop)\n                    boxZTop = transformedMvertices[j + 2];\n            }\n            collisionData.push({\n                planeNormal: objectPlaneNormal,\n                playerBoxZdelta: boxZTop - playerZBottom,\n            });\n        }\n        else {\n            const playerPlaneNormal = line_plane_collision_test(modelCenter, transformedMvertices, transformedPverticesGrouped);\n            if (playerPlaneNormal) {\n                for (let j = 0; j < transformedMvertices.length; j += 3) {\n                    if (transformedMvertices[j + 2] > boxZTop)\n                        boxZTop = transformedMvertices[j + 2];\n                }\n                collisionData.push({\n                    planeNormal: (0,_math_stuff__WEBPACK_IMPORTED_MODULE_0__.num_vec_multiply)(-1, playerPlaneNormal),\n                    playerBoxZdelta: boxZTop - playerZBottom,\n                });\n            }\n        }\n        g_index += 24 * 3;\n    }\n    if (collisionData.length)\n        return collisionData;\n    return false;\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/utils/collisions.ts?");

/***/ }),

/***/ "./src/utils/math_stuff.ts":
/*!*********************************!*\
  !*** ./src/utils/math_stuff.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cross: () => (/* binding */ cross),\n/* harmony export */   degToRad: () => (/* binding */ degToRad),\n/* harmony export */   dot: () => (/* binding */ dot),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   num_divide_by_vec: () => (/* binding */ num_divide_by_vec),\n/* harmony export */   num_vec_multiply: () => (/* binding */ num_vec_multiply),\n/* harmony export */   vec3_mean: () => (/* binding */ vec3_mean),\n/* harmony export */   vecA_divide_by_vecB: () => (/* binding */ vecA_divide_by_vecB),\n/* harmony export */   vecA_minus_vecB: () => (/* binding */ vecA_minus_vecB),\n/* harmony export */   vecAdd: () => (/* binding */ vecAdd),\n/* harmony export */   vec_multiply: () => (/* binding */ vec_multiply)\n/* harmony export */ });\nfunction degToRad(theta) {\n    return (theta * Math.PI) / 180;\n}\nfunction normalize(v, dst) {\n    dst = dst || [];\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\nfunction cross(a, b, dst) {\n    dst = dst || [];\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\nfunction vecA_minus_vecB(a, b) {\n    return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n}\nfunction vecAdd(a, b) {\n    return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n}\nfunction vec_multiply(a, b) {\n    return [a[0] * b[0], a[1] * b[1], a[2] * b[2]];\n}\nfunction vecA_divide_by_vecB(a, b) {\n    return [a[0] / b[0], a[1] / b[1], a[2] / b[2]];\n}\nfunction num_vec_multiply(a, b) {\n    return [a * b[0], a * b[1], a * b[2]];\n}\nfunction num_divide_by_vec(a, b) {\n    return [a / b[0], a / b[1], a / b[2]];\n}\nfunction vec3_mean(vecs) {\n    const vecNum = vecs.length;\n    const newVec = vecs[0];\n    if (vecNum === 1)\n        return newVec;\n    for (let i = 1; i < vecs.length; i++) {\n        newVec[0] += vecs[i][0];\n        newVec[1] += vecs[i][1];\n        newVec[2] += vecs[i][2];\n    }\n    return [newVec[0] / vecNum, newVec[1] / vecNum, newVec[2] / vecNum];\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/utils/math_stuff.ts?");

/***/ }),

/***/ "./src/utils/matrices.ts":
/*!*******************************!*\
  !*** ./src/utils/matrices.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   one_four_by_four_four: () => (/* binding */ one_four_by_four_four)\n/* harmony export */ });\nfunction one_four_by_four_four(vertex, modelTransform) {\n    const v1 = vertex[0];\n    const v2 = vertex[1];\n    const v3 = vertex[2];\n    const v4 = 1;\n    const m1_1 = modelTransform[0];\n    const m1_2 = modelTransform[1];\n    const m1_3 = modelTransform[2];\n    // const m1_4: number = modelTransform[3];\n    const m2_1 = modelTransform[4];\n    const m2_2 = modelTransform[5];\n    const m2_3 = modelTransform[6];\n    // const m2_4: number = modelTransform[7];\n    const m3_1 = modelTransform[8];\n    const m3_2 = modelTransform[9];\n    const m3_3 = modelTransform[10];\n    // const m3_4: number = modelTransform[11];\n    const m4_1 = modelTransform[12];\n    const m4_2 = modelTransform[13];\n    const m4_3 = modelTransform[14];\n    // const m4_4: number = modelTransform[15];\n    const col1 = v1 * m1_1 + v2 * m2_1 + v3 * m3_1 + v4 * m4_1;\n    const col2 = v1 * m1_2 + v2 * m2_2 + v3 * m3_2 + v4 * m4_2;\n    const col3 = v1 * m1_3 + v2 * m2_3 + v3 * m3_3 + v4 * m4_3;\n    return new Float32Array([col1, col2, col3]);\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/utils/matrices.ts?");

/***/ }),

/***/ "./src/view/light_mesh.ts":
/*!********************************!*\
  !*** ./src/view/light_mesh.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LightMesh: () => (/* binding */ LightMesh)\n/* harmony export */ });\n/* harmony import */ var _objectList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objectList */ \"./src/objectList.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass LightMesh {\n    constructor(device) {\n        this.device = device;\n        this.brightnessValues = {};\n        this.colorValues = {};\n        this.lightPositions = {};\n        this.tempArr = [];\n        this.lightCount = 0;\n        this.lightPositionArr = [];\n        this.brightnessArr = [];\n        this.colorValueArr = [];\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList).length; i++) {\n                const name = Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList)[i];\n                if (!_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList[name].hasLights)\n                    continue;\n                const mtl_file_contents = yield fetch(`dist/lights/${name}_l.mtl`).then(res => res.text());\n                const obj_file_contents = yield fetch(`dist/lights/${name}_l.obj`).then(res => res.text());\n                const mtl_lines = mtl_file_contents.split('\\n');\n                const obj_lines = obj_file_contents.split('\\n');\n                this.read_mtl_file(mtl_lines);\n                this.read_obj_file(obj_lines, name);\n            }\n            this.vertices = new Float32Array(this.lightPositionArr.concat(this.brightnessArr).concat(this.colorValueArr));\n            this.buffer = this.device.createBuffer({\n                label: 'Light Data Buffer',\n                size: this.vertices.byteLength,\n                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n                mappedAtCreation: true,\n            });\n            new Float32Array(this.buffer.getMappedRange()).set(this.vertices);\n            this.buffer.unmap();\n            // this.bufferLayout = {\n            // \tarrayStride: 28,\n            // \tattributes: [\n            // \t\t// For the position\n            // \t\t{\n            // \t\t\tshaderLocation: 4,\n            // \t\t\tformat: 'float32x3',\n            // \t\t\toffset: 0,\n            // \t\t},\n            // \t\t// For the Brightness\n            // \t\t{\n            // \t\t\tshaderLocation: 5,\n            // \t\t\tformat: 'float32',\n            // \t\t\toffset: 12,\n            // \t\t},\n            // \t\t// For the Color\n            // \t\t{\n            // \t\t\tshaderLocation: 6,\n            // \t\t\tformat: 'float32x3',\n            // \t\t\toffset: 16,\n            // \t\t},\n            // \t],\n            // };\n        });\n    }\n    read_mtl_file(lines) {\n        return __awaiter(this, void 0, void 0, function* () {\n            lines.forEach(l => {\n                const words = l.trim().split(' ');\n                if (words[0] === 'newmtl') {\n                    this.currentLightType = words[1];\n                }\n                else if (words[0] === 'Ns') {\n                    this.brightnessValues[this.currentLightType] = Number(words[1]);\n                }\n                else if (words[0] === 'Ke') {\n                    this.colorValues[this.currentLightType] = [Number(words[1]), Number(words[2]), Number(words[3])];\n                }\n            });\n        });\n    }\n    read_obj_file(lines, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            lines.forEach(l => {\n                const words = l.trim().split(' ');\n                if (words[0] === 'usemtl') {\n                    this.currentLightType = words[1];\n                }\n                else if (words[0] === 'v') {\n                    const components = words.filter(n => n);\n                    const position = [Number(components[1]), Number(components[2]), Number(components[3])];\n                    for (let i = 0; i < _objectList__WEBPACK_IMPORTED_MODULE_0__.objectList[name].models.length; i++) {\n                        // this.tempArr.push(\n                        // \t...position,\n                        // \tthis.brightnessValues[this.currentLightType],\n                        // \t...this.colorValues[this.currentLightType]\n                        // );\n                        this.lightPositionArr.push(...position);\n                        this.lightPositionArr.push(this.brightnessValues[this.currentLightType]);\n                        this.lightPositionArr.push(...this.colorValues[this.currentLightType]);\n                        this.lightCount++;\n                    }\n                    if (!this.lightPositions[name])\n                        this.lightPositions[name] = [];\n                    this.lightPositions[name].push(position);\n                }\n            });\n        });\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/view/light_mesh.ts?");

/***/ }),

/***/ "./src/view/material.ts":
/*!******************************!*\
  !*** ./src/view/material.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Material: () => (/* binding */ Material)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Material {\n    initialize(device, images, bindGroupLayout, depthStencilView) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const viewDescriptor = {\n                format: 'rgba8unorm',\n                dimension: '2d-array',\n                aspect: 'all',\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                baseArrayLayer: 0,\n                arrayLayerCount: Object.keys(images).length,\n            };\n            const samplerDescriptor = {\n                addressModeU: 'repeat',\n                addressModeV: 'repeat',\n                magFilter: 'linear',\n                minFilter: 'nearest',\n                mipmapFilter: 'linear',\n                maxAnisotropy: 1,\n            };\n            if (Object.keys(images).length) {\n                yield this.loadImageBitmap(device, images);\n                this.view = this.texture.createView(viewDescriptor);\n            }\n            else {\n                this.texture = device.createTexture({\n                    label: 'Combined Texture Descriptor',\n                    size: {\n                        width: 1,\n                        height: 1,\n                        depthOrArrayLayers: 1,\n                    },\n                    format: 'rgba8unorm',\n                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n                });\n                this.view = this.texture.createView({\n                    format: 'rgba8unorm',\n                    dimension: '2d-array',\n                    aspect: 'all',\n                    baseMipLevel: 0,\n                    mipLevelCount: 1,\n                    baseArrayLayer: 0,\n                    arrayLayerCount: 1,\n                });\n            }\n            this.sampler = device.createSampler(samplerDescriptor);\n            const depthSamplerDescritor = {\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'clamp-to-edge',\n                addressModeW: 'clamp-to-edge',\n                magFilter: 'linear',\n                minFilter: 'linear',\n                mipmapFilter: 'nearest',\n                maxAnisotropy: 1,\n                compare: 'less-equal',\n            };\n            this.depthSampler = device.createSampler(depthSamplerDescritor);\n            this.bindGroup = device.createBindGroup({\n                layout: bindGroupLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: this.view,\n                    },\n                    {\n                        binding: 1,\n                        resource: this.sampler,\n                    },\n                    {\n                        binding: 2,\n                        resource: depthStencilView,\n                    },\n                    {\n                        binding: 3,\n                        resource: this.depthSampler,\n                    },\n                ],\n            });\n        });\n    }\n    // appendBuffer(buffer1: ArrayBuffer, buffer2: ArrayBuffer): ArrayBuffer {\n    // \tlet tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    // \ttmp.set(new Uint8Array(buffer1), 0);\n    // \ttmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    // \treturn tmp.buffer;\n    // }\n    getMaxSize(urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let width = 0;\n            let height = 0;\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                const res = yield fetch(url);\n                const blob = yield res.blob();\n                const imageData = yield createImageBitmap(blob);\n                if (imageData.width > width)\n                    width = imageData.width;\n                if (imageData.height > height)\n                    height = imageData.height;\n            }\n            return { width, height };\n        });\n    }\n    fetchAndDecodeImage(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = yield fetch(url);\n            const blob = yield res.blob();\n            const bitmap = yield createImageBitmap(blob);\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const context = canvas.getContext('2d');\n            context.drawImage(bitmap, 0, 0);\n            return context.getImageData(0, 0, canvas.width, canvas.height);\n        });\n    }\n    loadImageBitmap(device, images) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const urls = Object.values(images);\n            const layers = urls.length;\n            const { width, height } = yield this.getMaxSize(urls);\n            const combinedTextureData = new Uint8Array(width * height * 4 * layers);\n            for (let i = 0; i < layers; i++) {\n                const url = urls[i];\n                const imageData = yield this.fetchAndDecodeImage(url);\n                const imageDataArray = new Uint8Array(imageData.data.buffer);\n                const offset = i * width * height * 4;\n                combinedTextureData.set(imageDataArray, offset);\n            }\n            if (!(combinedTextureData === null || combinedTextureData === void 0 ? void 0 : combinedTextureData.byteLength))\n                return;\n            const textureDescriptor = {\n                label: 'Combined Texture Descriptor',\n                size: {\n                    width: width,\n                    height: height,\n                    depthOrArrayLayers: urls.length,\n                },\n                format: 'rgba8unorm',\n                // Texture not always used as a render attachment\n                // but webGPU sometimes requires that usage flag\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n            };\n            this.texture = device.createTexture(textureDescriptor);\n            device.queue.writeTexture({ texture: this.texture }, combinedTextureData, { bytesPerRow: width * 4, rowsPerImage: height }, textureDescriptor.size);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/view/material.ts?");

/***/ }),

/***/ "./src/view/obj_mesh.ts":
/*!******************************!*\
  !*** ./src/view/obj_mesh.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjMesh: () => (/* binding */ ObjMesh)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass ObjMesh {\n    constructor(device) {\n        this.device = device;\n        this.vertices = new Float32Array([]);\n        this.vb = [];\n        this.vCount = 0;\n        this.vtCount = 0;\n        this.vnCount = 0;\n        this.materialFilenames = {};\n        this.materialSpecualar = {};\n        this.materialAmbient = {};\n        this.materialDiffuse = {};\n        this.materialShininess = {};\n        this.materialIndeces = {};\n    }\n    set_model_name(name) {\n        this.modelName = name;\n    }\n    group_by_face(vertices, lines) {\n        const newArr = [];\n        lines.forEach(l => {\n            const line = l.trim();\n            if (line[0] === 'f') {\n                const faceIndeces = line.split(' ').map(l => l.split('/')[0]);\n                newArr.push(...vertices[Number(faceIndeces[1]) - 1]);\n                newArr.push(...vertices[Number(faceIndeces[2]) - 1]);\n                newArr.push(...vertices[Number(faceIndeces[3]) - 1]);\n                newArr.push(...vertices[Number(faceIndeces[4]) - 1]);\n            }\n        });\n        return new Float32Array(newArr);\n    }\n    generate_bounding_boxes(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const file_contents = yield fetch(url).then(res => res.text());\n            const lines = file_contents.split('\\n');\n            let result = [];\n            lines.forEach(l => {\n                const line = l.trim();\n                if (line[0] === 'v' && line[1] === ' ') {\n                    this.read_vertex_line_b(line);\n                }\n                else if (line[0] === 'f') {\n                    this.read_face_line_b(line, result);\n                }\n            });\n            this.boundingBoxVertices = new Float32Array(result);\n            this.boundingBoxVertexCount = this.boundingBoxVertices.length / 3;\n            this.boundingBoxVerticesInitial = new Float32Array(this.vb.flat());\n            this.boundingBoxVerticesGrouped = this.group_by_face(this.vb, lines);\n            this.boundingBoxBuffer = this.device.createBuffer({\n                size: this.boundingBoxVertices.byteLength,\n                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n                mappedAtCreation: true,\n            });\n            new Float32Array(this.boundingBoxBuffer.getMappedRange()).set(this.boundingBoxVertices);\n            this.boundingBoxBuffer.unmap();\n        });\n    }\n    set_sizes(lines) {\n        let vNum = 0;\n        let vtNum = 0;\n        let vnNum = 0;\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i][0] === 'v' && lines[i][1] === ' ')\n                vNum += 3;\n            else if (lines[i][0] === 'v' && lines[i][1] === 't')\n                vtNum += 2;\n            else if (lines[i][0] === 'v' && lines[i][1] === 'n')\n                vnNum += 3;\n        }\n        this.v = new Float32Array(vNum);\n        this.vt = new Float32Array(vtNum);\n        this.vn = new Float32Array(vnNum);\n    }\n    initialize(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // prettier-ignore\n            yield this.read_mtl_file(url);\n            yield this.read_obj_file(url);\n            this.vertexCount = this.vertices.length / 19;\n            this.buffer = this.device.createBuffer({\n                label: 'Obj Mesh Buffer',\n                size: this.vertices.byteLength,\n                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n                mappedAtCreation: true,\n            });\n            new Float32Array(this.buffer.getMappedRange()).set(this.vertices);\n            this.buffer.unmap();\n            this.bufferLayout = {\n                arrayStride: 76,\n                attributes: [\n                    // For the position\n                    {\n                        shaderLocation: 0,\n                        format: 'float32x3',\n                        offset: 0,\n                    },\n                    // For the UVs\n                    {\n                        shaderLocation: 1,\n                        format: 'float32x2',\n                        offset: 12,\n                    },\n                    // For the material indeces\n                    {\n                        shaderLocation: 2,\n                        format: 'float32',\n                        offset: 20,\n                    },\n                    // For the face normals\n                    {\n                        shaderLocation: 3,\n                        format: 'float32x3',\n                        offset: 24,\n                    },\n                    // For Shininess (Ns)\n                    {\n                        shaderLocation: 4,\n                        format: 'float32',\n                        offset: 36,\n                    },\n                    // For Specular (Ks)\n                    {\n                        shaderLocation: 5,\n                        format: 'float32x3',\n                        offset: 40,\n                    },\n                    // For Ambient (Ka)\n                    {\n                        shaderLocation: 6,\n                        format: 'float32x3',\n                        offset: 52,\n                    },\n                    // For Diffuse (Kd)\n                    {\n                        shaderLocation: 7,\n                        format: 'float32x3',\n                        offset: 64,\n                    },\n                ],\n            };\n        });\n    }\n    read_mtl_file(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const file_contents = yield fetch(`${url}.mtl`).then(res => res.text());\n            const lines = file_contents.split('\\n');\n            let materialCount = 0;\n            lines.forEach(l => {\n                const words = l.trim().split(' ');\n                if (words[0] === 'newmtl') {\n                    this.currentMaterial = words[1];\n                }\n                else if (words[0] === 'map_Kd') {\n                    const filenameValues = Object.values(this.materialFilenames);\n                    if (filenameValues.includes(words[1])) {\n                        this.materialIndeces[this.currentMaterial] = filenameValues.indexOf(words[1]);\n                    }\n                    else {\n                        this.materialFilenames[this.currentMaterial] = words[1];\n                        this.materialIndeces[this.currentMaterial] = materialCount;\n                        materialCount++;\n                    }\n                }\n                else if (words[0] === 'Ka') {\n                    this.materialAmbient[this.currentMaterial] = [Number(words[1]), Number(words[2]), Number(words[3])];\n                }\n                else if (words[0] === 'Ks') {\n                    this.materialSpecualar[this.currentMaterial] = [Number(words[1]), Number(words[2]), Number(words[3])];\n                }\n                else if (words[0] === 'Ns') {\n                    this.materialShininess[this.currentMaterial] = Number(words[1]);\n                }\n                else if (words[0] === 'Kd') {\n                    this.materialDiffuse[this.currentMaterial] = [Number(words[1]), Number(words[2]), Number(words[3])];\n                }\n            });\n        });\n    }\n    read_obj_file(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result = [];\n            // Fetch object and split into array of strings\n            // where each new line is an element in the array\n            const file_contents = yield fetch(`${url}.obj`).then(res => res.text());\n            const lines = file_contents.split('\\n');\n            this.set_sizes(lines);\n            lines.forEach(l => {\n                const line = l.trim();\n                if (line[0] === 'v' && line[1] === ' ') {\n                    this.read_vertex_line(line);\n                }\n                else if (line[0] === 'v' && line[1] === 't') {\n                    this.read_texcoord_line(line);\n                }\n                else if (line[0] === 'v' && line[1] === 'n') {\n                    this.read_normal_line(line);\n                }\n                else if (line.split(' ')[0] === 'usemtl') {\n                    this.currentMaterial = line.split(' ')[1];\n                }\n                else if (line[0] === 'f') {\n                    this.read_face_line(line, result);\n                    if (result.length >= 10000000) {\n                        const arrTemp = new Float32Array(this.vertices.length + result.length);\n                        arrTemp.set(this.vertices);\n                        arrTemp.set(result, this.vertices.length);\n                        this.vertices = arrTemp;\n                        result = [];\n                    }\n                }\n            });\n            const arrTemp = new Float32Array(this.vertices.length + result.length);\n            arrTemp.set(this.vertices);\n            arrTemp.set(result, this.vertices.length);\n            this.vertices = arrTemp;\n            result = [];\n        });\n    }\n    read_vertex_line(line) {\n        // What we have: ['v', x, y, z]\n        const components = line.split(' ').filter(n => n);\n        // What we want: [x, y, z]\n        const newVertex = [Number(components[1]), Number(components[2]), Number(components[3])];\n        // this.v.push(newVertex);\n        this.v[this.vCount] = newVertex[0];\n        this.v[this.vCount + 1] = newVertex[1];\n        this.v[this.vCount + 2] = newVertex[2];\n        this.vCount += 3;\n    }\n    read_texcoord_line(line) {\n        // What we have: ['vt', u, v]\n        const components = line.split(' ').filter(n => n);\n        // What we want: [u, v]\n        const newTextcoord = [Number(components[1]), Number(components[2])];\n        // this.vt.push(newTextcoord);\n        this.vt[this.vtCount] = newTextcoord[0];\n        this.vt[this.vtCount + 1] = newTextcoord[1];\n        this.vtCount += 2;\n    }\n    read_normal_line(line) {\n        // What we have: ['vn', nx, ny, nz]\n        const components = line.split(' ').filter(n => n);\n        // What we want: [nx, ny, nz]\n        const newNormal = [Number(components[1]), Number(components[2]), Number(components[3])];\n        // this.vn.push(newNormal);\n        this.vn[this.vnCount] = newNormal[0];\n        this.vn[this.vnCount + 1] = newNormal[1];\n        this.vn[this.vnCount + 2] = newNormal[2];\n        this.vnCount += 3;\n    }\n    read_face_line(line, result) {\n        // Face line elements describe how the vertices are layed out\n        // to make the triangles for the polygon\n        line = line.replace('\\n', '');\n        const vertexDescriptions = line.split(' ').filter(n => n);\n        // What we have: ['f', v1, v2, ...]\n        // Number of triangles = # of vertices - 2 (-3 here because of the 'f' element)\n        const triangleCount = vertexDescriptions.length - 3;\n        for (let i = 0; i < triangleCount; i++) {\n            this.read_corner(vertexDescriptions[1], result);\n            this.read_corner(vertexDescriptions[2 + i], result);\n            this.read_corner(vertexDescriptions[3 + i], result);\n        }\n    }\n    read_corner(vertexDescription, res) {\n        const v_vt_vn = vertexDescription.split('/');\n        const vStart = (Number(v_vt_vn[0]) - 1) * 3;\n        const v = [this.v[vStart], this.v[vStart + 1], this.v[vStart + 2]];\n        const vtStart = (Number(v_vt_vn[1]) - 1) * 2;\n        const vt = [this.vt[vtStart], this.vt[vtStart + 1]];\n        const vnStart = (Number(v_vt_vn[2]) - 1) * 3;\n        const vn = [this.vn[vnStart], this.vn[vnStart + 1], this.vn[vnStart + 2]];\n        res.push(v[0]);\n        res.push(v[1]);\n        res.push(v[2]);\n        res.push(vt[0]);\n        res.push(vt[1]);\n        res.push(Number(this.materialIndeces[this.currentMaterial]) || 0);\n        res.push(vn[0]);\n        res.push(vn[1]);\n        res.push(vn[2]);\n        res.push(this.materialShininess[this.currentMaterial]);\n        res.push(...this.materialSpecualar[this.currentMaterial]);\n        res.push(...this.materialAmbient[this.currentMaterial]);\n        res.push(...this.materialDiffuse[this.currentMaterial]);\n    }\n    read_vertex_line_b(line) {\n        // What we have: ['v', x, y, z]\n        const components = line.split(' ').filter(n => n);\n        // What we want: [x, y, z]\n        const newVertex = [Number(components[1]), Number(components[2]), Number(components[3])];\n        this.vb.push(newVertex);\n    }\n    read_face_line_b(line, result) {\n        // Face line elements describe how the vertices are layed out\n        // to make the triangles for the polygon\n        line = line.replace('\\n', '');\n        const vertexDescriptions = line.split(' ').filter(n => n);\n        // What we have: ['f', v1, v2, ...]\n        // Number of triangles = # of vertices - 2 (-3 here because of the 'f' element)\n        const triangleCount = vertexDescriptions.length - 3;\n        // console.log(triangleCount);\n        for (let i = 0; i < triangleCount; i++) {\n            this.read_corner_b(vertexDescriptions[1], result);\n            this.read_corner_b(vertexDescriptions[2 + i], result);\n            this.read_corner_b(vertexDescriptions[3 + i], result);\n        }\n    }\n    read_corner_b(vertexDescription, res) {\n        const v_vt_vn = vertexDescription.split('/');\n        const v = this.vb[Number(v_vt_vn[0]) - 1];\n        // Can add in vn if wanted later\n        res.push(v[0]);\n        res.push(v[1]);\n        res.push(v[2]);\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/view/obj_mesh.ts?");

/***/ }),

/***/ "./src/view/renderer.ts":
/*!******************************!*\
  !*** ./src/view/renderer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js\");\n/* harmony import */ var _objectList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objectList */ \"./src/objectList.ts\");\n/* harmony import */ var _utils_math_stuff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math_stuff */ \"./src/utils/math_stuff.ts\");\n/* harmony import */ var _light_mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./light_mesh */ \"./src/view/light_mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./material */ \"./src/view/material.ts\");\n/* harmony import */ var _obj_mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj_mesh */ \"./src/view/obj_mesh.ts\");\n/* harmony import */ var _shaders_boundingBoxShader_wgsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shaders/boundingBoxShader.wgsl */ \"./src/view/shaders/boundingBoxShader.wgsl\");\n/* harmony import */ var _shaders_shader_wgsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shaders/shader.wgsl */ \"./src/view/shaders/shader.wgsl\");\n/* harmony import */ var _triangle_mesh__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./triangle_mesh */ \"./src/view/triangle_mesh.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\nclass Renderer {\n    constructor(canvas, collisionDebug) {\n        this.render = (renderables, cameraPosition) => {\n            // If zFar (last v + alue) is too large, depth buffer gets confused\n            const projection = wgpu_matrix__WEBPACK_IMPORTED_MODULE_8__.mat4.perspective(this.fov, this.aspect, 0.1, 50);\n            const view = renderables.viewTransform;\n            // Pass matrices into the same buffer\n            // Shader will take it in as an object with 3 matrices because of the way we set it up\n            this.device.queue.writeBuffer(this.objectBuffer, 0, renderables.modelTransforms, 0, renderables.modelTransforms.length);\n            this.device.queue.writeBuffer(this.lightMatrixBuffer, 0, renderables.lightTransforms, 0, renderables.lightTransforms.length);\n            if (this.collisionDebug) {\n                this.device.queue.writeBuffer(this.boundingBoxBuffer, 0, renderables.boundingBoxTransforms, 0, renderables.boundingBoxTransforms.length);\n            }\n            this.device.queue.writeBuffer(this.uniformBuffer, 0, view);\n            this.device.queue.writeBuffer(this.uniformBuffer, 64, projection);\n            this.device.queue.writeBuffer(this.cameraPosBuffer, 0, new Float32Array(cameraPosition));\n            this.device.queue.writeBuffer(this.vpDimensionBuffer, 0, new Float32Array([this.canvas.width, this.canvas.height]));\n            this.encoder = this.device.createCommandEncoder();\n            this.view = this.context.getCurrentTexture().createView();\n            this.renderPass = this.encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: this.view,\n                        loadOp: 'clear',\n                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                        storeOp: 'store',\n                    },\n                ],\n                depthStencilAttachment: this.depthStencilAttachment,\n            });\n            this.renderPass.setPipeline(this.pipeline);\n            this.renderPass.setBindGroup(0, this.frameBindGroup);\n            let objectsDrawn = 0;\n            // Models\n            for (let i = 0; i < _objectList__WEBPACK_IMPORTED_MODULE_0__.objectCount; i++) {\n                this.renderPass.setVertexBuffer(0, this.objectMeshes[i].buffer);\n                this.renderPass.setBindGroup(1, this.objectMaterials[i].bindGroup);\n                this.renderPass.draw(this.objectMeshes[i].vertexCount, 1, 0, objectsDrawn);\n                objectsDrawn++;\n            }\n            if (this.collisionDebug) {\n                this.renderPass.setPipeline(this.boundingBoxPipeline);\n                this.renderPass.setBindGroup(0, this.boundingBoxBindGroup);\n                // Bounding Boxes\n                let b_index = 0;\n                for (let i = 0; i < _objectList__WEBPACK_IMPORTED_MODULE_0__.objectCount; i++) {\n                    const name = Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList)[i];\n                    const object = _objectList__WEBPACK_IMPORTED_MODULE_0__.objectList[name];\n                    if (object.hasBoundingBox) {\n                        this.renderPass.setVertexBuffer(0, this.objectMeshes[i].boundingBoxBuffer);\n                        this.renderPass.draw(this.objectMeshes[i].boundingBoxVertexCount, 1, 0, b_index);\n                        b_index++;\n                    }\n                }\n            }\n            this.renderPass.end();\n            this.device.queue.submit([this.encoder.finish()]);\n        };\n        this.collisionDebug = collisionDebug;\n        this.canvas = canvas;\n        this.context = canvas.getContext('webgpu');\n        this.fov = (0,_utils_math_stuff__WEBPACK_IMPORTED_MODULE_1__.degToRad)(60);\n        this.aspect = this.canvas.width / this.canvas.height;\n        this.objectMeshes = [];\n        this.objectMaterials = [];\n    }\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.makeBindGroupLayouts();\n            yield this.makeDepthBufferResources();\n            yield this.createAssets();\n            yield this.makePipelines();\n            yield this.makeBindGroup();\n        });\n    }\n    setupDevice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.adapter = (yield navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }));\n            this.device = (yield this.adapter.requestDevice());\n            this.format = navigator.gpu.getPreferredCanvasFormat();\n            this.shaderModule = this.device.createShaderModule({ label: 'shader', code: _shaders_shader_wgsl__WEBPACK_IMPORTED_MODULE_6__[\"default\"] });\n            this.boundingBoxShaderModule = (this.device.createShaderModule({ label: 'bounding box shader', code: _shaders_boundingBoxShader_wgsl__WEBPACK_IMPORTED_MODULE_5__[\"default\"] }));\n            this.context.configure({\n                device: this.device,\n                format: this.format,\n                alphaMode: 'premultiplied',\n            });\n        });\n    }\n    initLights() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Parsing Light Mesh');\n            this.lightMesh = new _light_mesh__WEBPACK_IMPORTED_MODULE_2__.LightMesh(this.device);\n            yield this.lightMesh.init();\n        });\n    }\n    createAssets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.uniformBuffer = this.device.createBuffer({\n                // values in a 4x4 matrix * bytes per value * # of matrices\n                label: 'Uniform Buffer',\n                size: 16 * 4 * 2,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            this.objectBuffer = this.device.createBuffer({\n                // values in a 4x4 matrix * bytes per value * # of matrices\n                label: 'Object Buffer',\n                size: 4 * 16 * _objectList__WEBPACK_IMPORTED_MODULE_0__.objectCount,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.lightMatrixBuffer = this.device.createBuffer({\n                label: 'Light Matrix Buffer',\n                size: 4 * 16 * this.lightMesh.lightCount || 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.lightDataBuffer = this.device.createBuffer({\n                label: 'Light Data Buffer',\n                size: this.lightMesh.vertices.byteLength || 12,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.cameraPosBuffer = this.device.createBuffer({\n                label: 'CameraPos Buffer',\n                size: 4 * 3,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            this.vpDimensionBuffer = this.device.createBuffer({\n                label: 'Uniform Buffer',\n                size: 4 * 2,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            if (this.collisionDebug) {\n                this.boundingBoxBuffer = this.device.createBuffer({\n                    // values in a 4x4 matrix * bytes per value * # of matrices\n                    label: 'bounding box buffer',\n                    size: 4 * 16 * _objectList__WEBPACK_IMPORTED_MODULE_0__.boundingBoxCount,\n                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n                });\n            }\n            this.triangleMesh = new _triangle_mesh__WEBPACK_IMPORTED_MODULE_7__.TriangleMesh(this.device);\n            let objectTotal = 0;\n            for (let i = 0; i < Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList).length; i++) {\n                const name = Object.keys(_objectList__WEBPACK_IMPORTED_MODULE_0__.objectList)[i];\n                const object = _objectList__WEBPACK_IMPORTED_MODULE_0__.objectList[name];\n                const modelCount = object.models.length;\n                for (let j = 0; j < modelCount; j++) {\n                    this.objectMeshes[objectTotal] = new _obj_mesh__WEBPACK_IMPORTED_MODULE_4__.ObjMesh(this.device);\n                    console.log(objectTotal, `Parsing ${name} object`);\n                    yield this.objectMeshes[objectTotal].initialize(`dist/models/${name}/${name}`);\n                    this.objectMeshes[objectTotal].set_model_name(name);\n                    if (object.hasBoundingBox) {\n                        console.log(objectTotal, `Parsing ${name} bounding box`);\n                        yield this.objectMeshes[objectTotal].generate_bounding_boxes(`dist/boundingBoxes/${name}_b.obj`);\n                    }\n                    this.objectMaterials[objectTotal] = new _material__WEBPACK_IMPORTED_MODULE_3__.Material();\n                    yield this.objectMaterials[objectTotal].initialize(this.device, this.objectMeshes[objectTotal].materialFilenames, this.materialBindGroupLayout, this.depthView);\n                    objectTotal++;\n                }\n            }\n        });\n    }\n    makeDepthBufferResources() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.depthStencilState = {\n                format: 'depth24plus',\n                depthWriteEnabled: true,\n                depthCompare: 'less',\n            };\n            const size = {\n                width: this.canvas.width,\n                height: this.canvas.height,\n                depthOrArrayLayers: 1,\n            };\n            this.depthStencilBuffer = this.device.createTexture({\n                size: size,\n                format: 'depth24plus',\n                usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n            const depthBuffer = this.device.createTexture({\n                size: size,\n                format: 'depth24plus',\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                mipLevelCount: 1,\n                sampleCount: 1,\n            });\n            this.depthStencilView = this.depthStencilBuffer.createView({\n                format: 'depth24plus',\n                dimension: '2d',\n                aspect: 'depth-only',\n            });\n            this.depthView = depthBuffer.createView({\n                format: 'depth24plus',\n                dimension: '2d',\n                aspect: 'depth-only',\n            });\n            this.depthStencilAttachment = {\n                view: this.depthStencilView,\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n            };\n        });\n    }\n    makeBindGroupLayouts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.frameBindGroupLayout = this.device.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        visibility: GPUShaderStage.VERTEX,\n                        buffer: {},\n                    },\n                    {\n                        binding: 1,\n                        visibility: GPUShaderStage.VERTEX,\n                        buffer: {\n                            type: 'read-only-storage',\n                            hasDynamicOffset: false,\n                        },\n                    },\n                    {\n                        binding: 2,\n                        visibility: GPUShaderStage.VERTEX,\n                        buffer: {},\n                    },\n                    {\n                        binding: 3,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        buffer: {},\n                    },\n                    {\n                        binding: 4,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        buffer: {\n                            type: 'read-only-storage',\n                            hasDynamicOffset: false,\n                        },\n                    },\n                    {\n                        binding: 5,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        buffer: {\n                            type: 'read-only-storage',\n                            hasDynamicOffset: false,\n                        },\n                    },\n                ],\n            });\n            if (this.collisionDebug) {\n                this.boundingBoxBindGroupLayout = this.device.createBindGroupLayout({\n                    label: 'bounding box bind group layout',\n                    entries: [\n                        {\n                            binding: 0,\n                            visibility: GPUShaderStage.VERTEX,\n                            buffer: {},\n                        },\n                        {\n                            binding: 1,\n                            visibility: GPUShaderStage.VERTEX,\n                            buffer: {\n                                type: 'read-only-storage',\n                                hasDynamicOffset: false,\n                            },\n                        },\n                    ],\n                });\n            }\n            this.materialBindGroupLayout = this.device.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        texture: {\n                            viewDimension: '2d-array',\n                        },\n                    },\n                    {\n                        binding: 1,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        sampler: {},\n                    },\n                    {\n                        binding: 2,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        texture: {\n                            sampleType: 'depth',\n                            viewDimension: '2d',\n                            multisampled: false,\n                        },\n                    },\n                    {\n                        binding: 3,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        sampler: {\n                            type: 'comparison',\n                        },\n                    },\n                ],\n            });\n        });\n    }\n    makeBindGroup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.frameBindGroup = this.device.createBindGroup({\n                label: 'Frame Bind Group',\n                layout: this.frameBindGroupLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: this.uniformBuffer,\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: this.objectBuffer,\n                        },\n                    },\n                    {\n                        binding: 2,\n                        resource: {\n                            buffer: this.cameraPosBuffer,\n                        },\n                    },\n                    {\n                        binding: 3,\n                        resource: {\n                            buffer: this.vpDimensionBuffer,\n                        },\n                    },\n                    {\n                        binding: 4,\n                        resource: {\n                            buffer: this.lightMatrixBuffer,\n                        },\n                    },\n                    {\n                        binding: 5,\n                        resource: {\n                            buffer: this.lightDataBuffer,\n                        },\n                    },\n                ],\n            });\n            const lightPos = new Float32Array(this.lightMesh.lightPositionArr);\n            const brightness = new Float32Array(this.lightMesh.brightnessArr);\n            const color = new Float32Array(this.lightMesh.colorValueArr);\n            if (lightPos) {\n                this.device.queue.writeBuffer(this.lightDataBuffer, 0, lightPos);\n                this.device.queue.writeBuffer(this.lightDataBuffer, lightPos.byteLength, brightness);\n                this.device.queue.writeBuffer(this.lightDataBuffer, brightness.byteLength, color);\n            }\n            else {\n                this.device.queue.writeBuffer(this.lightDataBuffer, 0, new Float32Array(0));\n                this.device.queue.writeBuffer(this.lightDataBuffer, 4, new Float32Array(0));\n                this.device.queue.writeBuffer(this.lightDataBuffer, 8, new Float32Array(0));\n            }\n            if (this.collisionDebug) {\n                this.boundingBoxBindGroup = this.device.createBindGroup({\n                    label: 'bounding box bing group',\n                    layout: this.boundingBoxBindGroupLayout,\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: {\n                                buffer: this.uniformBuffer,\n                            },\n                        },\n                        {\n                            binding: 1,\n                            resource: {\n                                buffer: this.boundingBoxBuffer,\n                            },\n                        },\n                    ],\n                });\n            }\n        });\n    }\n    makePipelines() {\n        this.pipeline = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [this.frameBindGroupLayout, this.materialBindGroupLayout],\n            }),\n            vertex: {\n                module: this.shaderModule,\n                entryPoint: 'v_main',\n                // Same buffer layout for all object types\n                buffers: [this.objectMeshes[0].bufferLayout],\n            },\n            fragment: {\n                module: this.shaderModule,\n                entryPoint: 'f_main',\n                targets: [\n                    {\n                        format: this.format,\n                    },\n                ],\n            },\n            primitive: {\n                topology: this.collisionDebug ? 'line-list' : 'triangle-list',\n            },\n            depthStencil: this.depthStencilState,\n        });\n        if (this.collisionDebug) {\n            this.boundingBoxPipeline = this.device.createRenderPipeline({\n                label: 'bounding box pipeline',\n                layout: this.device.createPipelineLayout({\n                    bindGroupLayouts: [this.boundingBoxBindGroupLayout],\n                }),\n                vertex: {\n                    module: this.boundingBoxShaderModule,\n                    entryPoint: 'v_main',\n                    buffers: [\n                        {\n                            arrayStride: 12,\n                            attributes: [\n                                {\n                                    shaderLocation: 0,\n                                    format: 'float32x3',\n                                    offset: 0,\n                                },\n                            ],\n                        },\n                    ],\n                },\n                fragment: {\n                    module: this.boundingBoxShaderModule,\n                    entryPoint: 'f_main',\n                    targets: [\n                        {\n                            format: this.format,\n                            blend: {\n                                color: {\n                                    srcFactor: 'one',\n                                    dstFactor: 'one-minus-src-alpha',\n                                },\n                                alpha: {\n                                    srcFactor: 'one',\n                                    dstFactor: 'one-minus-src-alpha',\n                                },\n                            },\n                        },\n                    ],\n                },\n                primitive: {\n                    topology: 'triangle-list',\n                },\n                depthStencil: this.depthStencilState,\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/view/renderer.ts?");

/***/ }),

/***/ "./src/view/triangle_mesh.ts":
/*!***********************************!*\
  !*** ./src/view/triangle_mesh.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TriangleMesh: () => (/* binding */ TriangleMesh)\n/* harmony export */ });\nclass TriangleMesh {\n    constructor(device) {\n        // prettier-ignore\n        this.vertices = new Float32Array([\n            // x y z u v\n            0.0, 0.0, 0.5, 0.5, 0.0,\n            0.0, -0.5, -0.5, 0.2, 1.0,\n            0.0, 0.5, -0.5, 0.8, 1.0,\n        ]);\n        this.buffer = device.createBuffer({\n            size: this.vertices.byteLength,\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Float32Array(this.buffer.getMappedRange()).set(this.vertices);\n        this.buffer.unmap();\n        this.bufferLayout = {\n            arrayStride: 20,\n            attributes: [\n                // For the position\n                {\n                    shaderLocation: 0,\n                    format: 'float32x3',\n                    offset: 0,\n                },\n                // For the color\n                {\n                    shaderLocation: 1,\n                    format: 'float32x2',\n                    offset: 12,\n                },\n            ],\n        };\n    }\n}\n\n\n//# sourceURL=webpack://basic_engine/./src/view/triangle_mesh.ts?");

/***/ }),

/***/ "./src/view/shaders/boundingBoxShader.wgsl":
/*!*************************************************!*\
  !*** ./src/view/shaders/boundingBoxShader.wgsl ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct TransformData {\\r\\n    view: mat4x4<f32>,\\r\\n    projection: mat4x4<f32>,\\r\\n};\\r\\n\\r\\nstruct ObjectData {\\r\\n    model: array<mat4x4<f32>>,\\r\\n};\\r\\n\\r\\nstruct VertIn {\\r\\n    @location(0) vertexPosition: vec3f,\\r\\n    @builtin(instance_index) instanceIndex: u32,\\r\\n};\\r\\n\\r\\nstruct VertOut {\\r\\n    @builtin(position) position: vec4f,\\r\\n};\\r\\n\\r\\n@group(0) @binding(0) var<uniform> transformUBO: TransformData;\\r\\n@group(0) @binding(1) var<storage, read> objects: ObjectData;\\r\\n\\r\\n@vertex\\r\\nfn v_main(input: VertIn) -> VertOut {\\r\\n    var output: VertOut;\\r\\n\\r\\n    output.position = transformUBO.projection * transformUBO.view * objects.model[input.instanceIndex] * vec4f(input.vertexPosition, 1.0);\\r\\n\\r\\n    return output;\\r\\n}\\r\\n\\r\\n@fragment\\r\\nfn f_main(input: VertOut) -> @location(0) vec4f {\\r\\n    return vec4f(0.0, 1.0, 1.0, 0.1);\\r\\n}\");\n\n//# sourceURL=webpack://basic_engine/./src/view/shaders/boundingBoxShader.wgsl?");

/***/ }),

/***/ "./src/view/shaders/shader.wgsl":
/*!**************************************!*\
  !*** ./src/view/shaders/shader.wgsl ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct TransformData {\\r\\n    view: mat4x4<f32>,\\r\\n    projection: mat4x4<f32>,\\r\\n};\\r\\n\\r\\nstruct ObjectData {\\r\\n    model: array<mat4x4<f32>>,\\r\\n};\\r\\n\\r\\nstruct LightData {\\r\\n    model: array<mat4x4<f32>>,\\r\\n};\\r\\n\\r\\nstruct VertIn {\\r\\n    @location(0) vertexPosition: vec3f,\\r\\n    @location(1) vertexTexCoord: vec2f,\\r\\n    @location(2) materialIndex: f32,\\r\\n    @location(3) vertexNormal: vec3f,\\r\\n    @location(4) materialShininess: f32,\\r\\n    @location(5) materialSpecular: vec3f,\\r\\n    @location(6) materialAmbient: vec3f,\\r\\n    @location(7) materialDiffuse: vec3f,\\r\\n    @builtin(instance_index) instanceIndex: u32,\\r\\n};\\r\\n\\r\\nstruct VertOut {\\r\\n    @builtin(position) position: vec4f,\\r\\n    @location(0) TextCoord: vec2f,\\r\\n    @location(1) cameraPos: vec3f,\\r\\n    @location(2) worldPos: vec4f,\\r\\n    @location(3) @interpolate(flat) materialIndex: u32,\\r\\n    @location(4) @interpolate(flat) vertexNormal: vec3f,\\r\\n    @location(5) @interpolate(flat) materialShininess: f32,\\r\\n    @location(6) @interpolate(flat) materialSpecular: vec3f,\\r\\n    @location(7) @interpolate(flat) materialAmbient: vec3f,\\r\\n    @location(8) @interpolate(flat) materialDiffuse: vec3f,\\r\\n};\\r\\n\\r\\nstruct FragOut {\\r\\n    @location(0) color: vec4f,\\r\\n};\\r\\n\\r\\nconst fogIntensity: f32 = 0.04;\\r\\nconst fogColor = vec3f(0.0, 0.0, 0.0);\\r\\n\\r\\n// Bound for each frame\\r\\n@group(0) @binding(0) var<uniform> transformUBO: TransformData;\\r\\n@group(0) @binding(1) var<storage, read> objects: ObjectData;\\r\\n@group(0) @binding(2) var<uniform> cameraPosition: vec3f;\\r\\n@group(0) @binding(3) var<uniform> viewport: vec2f;\\r\\n\\r\\n@group(0) @binding(4) var<storage, read> lightData: LightData;\\r\\n@group(0) @binding(5) var<storage, read> lightPosition: vec3f;\\r\\n@group(0) @binding(6) var<storage, read> lightBrightness: f32;\\r\\n@group(0) @binding(7) var<storage, read> lightColor: vec3f;\\r\\n\\r\\n// Bound for each material\\r\\n@group(1) @binding(0) var myTexture: texture_2d_array<f32>;\\r\\n@group(1) @binding(1) var mySampler: sampler;\\r\\n@group(1) @binding(2) var myDepthTexture: texture_depth_2d;\\r\\n@group(1) @binding(3) var myDepthSampler: sampler_comparison;\\r\\n\\r\\n@vertex\\r\\nfn v_main(input: VertIn) -> VertOut {\\r\\n    var output: VertOut;\\r\\n    let vertWorlPos = objects.model[input.instanceIndex] * vec4f(input.vertexPosition, 1.0);\\r\\n\\r\\n    output.position = transformUBO.projection * transformUBO.view * vertWorlPos;\\r\\n    output.TextCoord = input.vertexTexCoord;\\r\\n    output.cameraPos = cameraPosition.xyz;\\r\\n    output.worldPos = vertWorlPos; \\r\\n    output.materialIndex = u32(input.materialIndex);\\r\\n    output.vertexNormal = input.vertexNormal;\\r\\n    output.materialShininess = input.materialShininess;\\r\\n    output.materialSpecular = input.materialSpecular;\\r\\n    output.materialAmbient = input.materialAmbient;\\r\\n    output.materialDiffuse = input.materialDiffuse;\\r\\n\\r\\n    return output;\\r\\n}\\r\\n\\r\\n@fragment\\r\\nfn f_main(input: VertOut) -> FragOut {\\r\\n    var output: FragOut;\\r\\n\\r\\n    let textureColor = textureSample(myTexture, mySampler, vec2f(input.TextCoord.x, 1 - input.TextCoord.y), input.materialIndex);\\r\\n    if (textureColor.a == 0.0) {\\r\\n        discard;\\r\\n    }\\r\\n\\r\\n    let distFromPlayer = abs(distance(input.worldPos.xyz, input.cameraPos));\\r\\n\\r\\n    let fogScaler = 1 - clamp(1 / exp(pow((distFromPlayer * fogIntensity), 2)), 0, 1);\\r\\n\\r\\n    let lightPos = vec3f(-5.0, -5.0, 10.0);\\r\\n    let lightDir = normalize(lightPos - input.worldPos.xyz);\\r\\n    let faceDirToCamera = normalize(input.worldPos.xyz - input.cameraPos);\\r\\n    \\r\\n    // let depthSample = textureSampleCompare(myDepthTexture, myDepthSampler, vec2f(input.TextCoord.x, 1 - input.TextCoord.y), 1.0);\\r\\n\\r\\n    // Ambient\\r\\n    let ka = 0.2;\\r\\n    let ambientLight = textureColor.rgb * input.materialAmbient * ka;\\r\\n\\r\\n    // Diffuse\\r\\n    var diffuseColor = input.materialDiffuse;\\r\\n    if (textureColor.r != 0 || textureColor.g != 0 || textureColor.b != 0) {\\r\\n        diffuseColor = textureColor.rgb;\\r\\n    }\\r\\n    let diffuseAmt = max(0.0, dot(lightDir, input.vertexNormal));\\r\\n    let diffuseLight = diffuseColor * diffuseAmt;\\r\\n\\r\\n    // Specular\\r\\n    let reflectedLight = reflect(lightDir, input.vertexNormal);\\r\\n    let specularAmt = pow(max(0.0, dot(reflectedLight, faceDirToCamera)), input.materialShininess);\\r\\n    let specularLight = specularAmt * input.materialSpecular;\\r\\n\\r\\n    let finalLight = ambientLight + diffuseLight + specularLight;\\r\\n\\r\\n    let finalWithFog = mix(finalLight, fogColor, fogScaler);\\r\\n\\r\\n    output.color = vec4f(finalWithFog, textureColor.a);\\r\\n    \\r\\n    return output;\\r\\n}\");\n\n//# sourceURL=webpack://basic_engine/./src/view/shaders/shader.wgsl?");

/***/ }),

/***/ "./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js":
/*!*****************************************************************!*\
  !*** ./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mat3: () => (/* binding */ mat3Impl),\n/* harmony export */   mat4: () => (/* binding */ mat4Impl),\n/* harmony export */   quat: () => (/* binding */ quatImpl),\n/* harmony export */   setDefaultType: () => (/* binding */ setDefaultType),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   vec2: () => (/* binding */ vec2Impl),\n/* harmony export */   vec3: () => (/* binding */ vec3Impl),\n/* harmony export */   vec4: () => (/* binding */ vec4Impl)\n/* harmony export */ });\n/* wgpu-matrix@2.5.1, license MIT */\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    setEpsilon: setEpsilon,\n    degToRad: degToRad,\n    radToDeg: radToDeg,\n    lerp: lerp$4,\n    inverseLerp: inverseLerp,\n    euclideanModulo: euclideanModulo\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$4(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Sets the values of a Vec2\n * Also see {@link vec2.create} and {@link vec2.copy}\n *\n * @param x first value\n * @param y second value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$5(x, y, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = x;\n    dst[1] = y;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec2.clone})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec2.copy})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$5,\n    setDefaultType: setDefaultType$6,\n    fromValues: fromValues$3,\n    set: set$5,\n    ceil: ceil$2,\n    floor: floor$2,\n    round: round$2,\n    clamp: clamp$2,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    subtract: subtract$3,\n    sub: sub$3,\n    equalsApproximately: equalsApproximately$5,\n    equals: equals$5,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mulScalar: mulScalar$3,\n    scale: scale$5,\n    divScalar: divScalar$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    cross: cross$1,\n    dot: dot$3,\n    length: length$3,\n    len: len$3,\n    lengthSq: lengthSq$3,\n    lenSq: lenSq$3,\n    distance: distance$2,\n    dist: dist$2,\n    distanceSq: distanceSq$2,\n    distSq: distSq$2,\n    normalize: normalize$3,\n    negate: negate$4,\n    copy: copy$5,\n    clone: clone$5,\n    multiply: multiply$5,\n    mul: mul$5,\n    divide: divide$2,\n    div: div$2,\n    random: random$1,\n    zero: zero$2,\n    transformMat4: transformMat4$2,\n    transformMat3: transformMat3$1\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$3(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat3\n * Also see {@link mat3.create} and {@link mat3.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 set from values.\n */\nfunction set$4(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n    dst = dst || newMat3();\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = 0;\n    dst[4] = v3;\n    dst[5] = v4;\n    dst[6] = v5;\n    dst[7] = 0;\n    dst[8] = v6;\n    dst[9] = v7;\n    dst[10] = v8;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat3.clone})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat3.copy})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const b01 = m22 * m11 - m12 * m21;\n    const b11 = -m22 * m10 + m12 * m20;\n    const b21 = m21 * m10 - m11 * m20;\n    const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n    dst[0] = b01 * invDet;\n    dst[1] = (-m22 * m01 + m02 * m21) * invDet;\n    dst[2] = (m12 * m01 - m02 * m11) * invDet;\n    dst[4] = b11 * invDet;\n    dst[5] = (m22 * m00 - m02 * m20) * invDet;\n    dst[6] = (-m12 * m00 + m02 * m10) * invDet;\n    dst[8] = b21 * invDet;\n    dst[9] = (-m21 * m00 + m01 * m20) * invDet;\n    dst[10] = (m11 * m00 - m01 * m10) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales uniformly in each dimension\n * @param s - Amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling$1(s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given.\n * @param m - The matrix to be modified.\n * @param s - Amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale$1(m, s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$4,\n    create: create$3,\n    set: set$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    negate: negate$3,\n    copy: copy$4,\n    clone: clone$4,\n    equalsApproximately: equalsApproximately$4,\n    equals: equals$4,\n    identity: identity$2,\n    transpose: transpose$1,\n    inverse: inverse$4,\n    determinant: determinant$1,\n    invert: invert$3,\n    multiply: multiply$4,\n    mul: mul$4,\n    setTranslation: setTranslation$1,\n    getTranslation: getTranslation$2,\n    getAxis: getAxis$2,\n    setAxis: setAxis$1,\n    getScaling: getScaling$2,\n    translation: translation$1,\n    translate: translate$1,\n    rotation: rotation$1,\n    rotate: rotate$1,\n    scaling: scaling$1,\n    scale: scale$4,\n    uniformScaling: uniformScaling$1,\n    uniformScale: uniformScale$1\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$4;\n/**\n * Sets the values of a Vec3\n * Also see {@link vec3.create} and {@link vec3.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$3(x, y, z, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec3.clone})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec3.copy})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec3 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Transforms vec3 by Quaternion\n * @param v - the vector to transform\n * @param q - the quaternion to transform by\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed\n */\nfunction transformQuat(v, q, dst) {\n    dst = dst || new VecType$1(3);\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const w2 = q[3] * 2;\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const uvX = qy * z - qz * y;\n    const uvY = qz * x - qx * z;\n    const uvZ = qx * y - qy * x;\n    dst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n    dst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n    dst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$4,\n    setDefaultType: setDefaultType$5,\n    fromValues: fromValues$2,\n    set: set$3,\n    ceil: ceil$1,\n    floor: floor$1,\n    round: round$1,\n    clamp: clamp$1,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    subtract: subtract$2,\n    sub: sub$2,\n    equalsApproximately: equalsApproximately$3,\n    equals: equals$3,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mulScalar: mulScalar$2,\n    scale: scale$3,\n    divScalar: divScalar$2,\n    inverse: inverse$3,\n    invert: invert$2,\n    cross: cross,\n    dot: dot$2,\n    length: length$2,\n    len: len$2,\n    lengthSq: lengthSq$2,\n    lenSq: lenSq$2,\n    distance: distance$1,\n    dist: dist$1,\n    distanceSq: distanceSq$1,\n    distSq: distSq$1,\n    normalize: normalize$2,\n    negate: negate$2,\n    copy: copy$3,\n    clone: clone$3,\n    multiply: multiply$3,\n    mul: mul$3,\n    divide: divide$1,\n    div: div$1,\n    random: random,\n    zero: zero$1,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    transformMat3: transformMat3,\n    transformQuat: transformQuat,\n    getTranslation: getTranslation$1,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat4\n * Also see {@link mat4.create} and {@link mat4.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 created from values.\n */\nfunction set$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = v3;\n    dst[4] = v4;\n    dst[5] = v5;\n    dst[6] = v6;\n    dst[7] = v7;\n    dst[8] = v8;\n    dst[9] = v9;\n    dst[10] = v10;\n    dst[11] = v11;\n    dst[12] = v12;\n    dst[13] = v13;\n    dst[14] = v14;\n    dst[15] = v15;\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat4.clone})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat4.copy})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$4();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$4();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$2(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$4();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    else {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n * @param s - the amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling(s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = s;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n * @param m - The matrix to be modified.\n * @param s - The amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale(m, s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[3] = s * m[0 * 4 + 3];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    dst[7] = s * m[1 * 4 + 3];\n    dst[8] = s * m[2 * 4 + 0];\n    dst[9] = s * m[2 * 4 + 1];\n    dst[10] = s * m[2 * 4 + 2];\n    dst[11] = s * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$3,\n    create: create$2,\n    set: set$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    negate: negate$1,\n    copy: copy$2,\n    clone: clone$2,\n    equalsApproximately: equalsApproximately$2,\n    equals: equals$2,\n    identity: identity$1,\n    transpose: transpose,\n    inverse: inverse$2,\n    determinant: determinant,\n    invert: invert$1,\n    multiply: multiply$2,\n    mul: mul$2,\n    setTranslation: setTranslation,\n    getTranslation: getTranslation,\n    getAxis: getAxis,\n    setAxis: setAxis,\n    getScaling: getScaling,\n    perspective: perspective,\n    ortho: ortho,\n    frustum: frustum,\n    aim: aim,\n    cameraAim: cameraAim,\n    lookAt: lookAt,\n    translation: translation,\n    translate: translate,\n    rotationX: rotationX,\n    rotateX: rotateX$1,\n    rotationY: rotationY,\n    rotateY: rotateY$1,\n    rotationZ: rotationZ,\n    rotateZ: rotateZ$1,\n    axisRotation: axisRotation,\n    rotation: rotation,\n    axisRotate: axisRotate,\n    rotate: rotate,\n    scaling: scaling,\n    scale: scale$2,\n    uniformScaling: uniformScaling,\n    uniformScale: uniformScale\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets the values of a Quat\n * Also see {@link quat.create} and {@link quat.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$1(x, y, z, w, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$4(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as {@link quat.clone})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as {@link quat.copy})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$4();\n    xUnitVec3 = xUnitVec3 || create$4(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$4(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$1,\n    setDefaultType: setDefaultType$2,\n    fromValues: fromValues$1,\n    set: set$1,\n    fromAxisAngle: fromAxisAngle,\n    toAxisAngle: toAxisAngle,\n    angle: angle,\n    multiply: multiply$1,\n    mul: mul$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    slerp: slerp,\n    inverse: inverse$1,\n    conjugate: conjugate,\n    fromMat: fromMat,\n    fromEuler: fromEuler,\n    copy: copy$1,\n    clone: clone$1,\n    add: add$1,\n    subtract: subtract$1,\n    sub: sub$1,\n    mulScalar: mulScalar$1,\n    scale: scale$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    lerp: lerp$1,\n    length: length$1,\n    len: len$1,\n    lengthSq: lengthSq$1,\n    lenSq: lenSq$1,\n    normalize: normalize$1,\n    equalsApproximately: equalsApproximately$1,\n    equals: equals$1,\n    identity: identity,\n    rotationTo: rotationTo,\n    sqlerp: sqlerp\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Sets the values of a Vec4\n * Also see {@link vec4.create} and {@link vec4.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set(x, y, z, w, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec4.clone})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec4.copy})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create,\n    setDefaultType: setDefaultType$1,\n    fromValues: fromValues,\n    set: set,\n    ceil: ceil,\n    floor: floor,\n    round: round,\n    clamp: clamp,\n    add: add,\n    addScaled: addScaled,\n    subtract: subtract,\n    sub: sub,\n    equalsApproximately: equalsApproximately,\n    equals: equals,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mulScalar: mulScalar,\n    scale: scale,\n    divScalar: divScalar,\n    inverse: inverse,\n    invert: invert,\n    dot: dot,\n    length: length,\n    len: len,\n    lengthSq: lengthSq,\n    lenSq: lenSq,\n    distance: distance,\n    dist: dist,\n    distanceSq: distanceSq,\n    distSq: distSq,\n    normalize: normalize,\n    negate: negate,\n    copy: copy,\n    clone: clone,\n    multiply: multiply,\n    mul: mul,\n    divide: divide,\n    div: div,\n    zero: zero,\n    transformMat4: transformMat4\n});\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$4(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$5(ctor);\n    setDefaultType$1(ctor);\n}\n\n\n//# sourceMappingURL=wgpu-matrix.module.js.map\n\n\n//# sourceURL=webpack://basic_engine/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;