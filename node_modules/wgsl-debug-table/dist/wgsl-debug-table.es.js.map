{"version":3,"file":"wgsl-debug-table.es.js","sources":["../../dist/wgsl-debug.es.js","../wgsl-debug-table.ts"],"sourcesContent":["const _WGSL_debug = class {\n  constructor(bindgroup_num, buf_unit_entries_count) {\n    this.shader_active = () => `@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;\n\nvar<private> _dbg_unit: u32;\n\nfn dbg_init(uid: u32) {\n\t/* initialize debug unit for this uid */\n\t_dbg_unit = ${_WGSL_debug.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;\n\t_dbg[_dbg_unit] = 0u; // entries count\n}\n\nfn dbg_32m(mark: i32, val: u32, vtype: i32) {\n\t/* limit entries count, but still store the total number of calls */\n\tvar entry_count = _dbg[_dbg_unit];\n\t_dbg[_dbg_unit] = entry_count + 1u;\n\tif (entry_count == ${this.buf_unit_entries_count}u) {\n\t\treturn;\n\t}\n\n\t/* store data in a new debug unit entry */\n\tvar entry_off = _dbg_unit + 1u + entry_count * ${_WGSL_debug.BUF_ENTRY_SIZE}u;\n\t_dbg[entry_off] = u32(vtype);\n\t_dbg[entry_off + 1u] = val;\n\t_dbg[entry_off + 2u] = u32(mark);\n}\n\nfn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${_WGSL_debug.BUF_ENTRY_TYPE_U32}); }\nfn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_I32}); }\nfn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_F32}); }\nfn dbg_32(val: u32, vtype: i32) { dbg_32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val, vtype); }\nfn dbg_u32(val: u32) { dbg_u32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_i32(val: i32) { dbg_i32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_f32(val: f32) { dbg_f32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }`;\n    this.buf_unit_size = () => _WGSL_debug.BUF_UNIT_HEADER_SIZE + this.buf_unit_entries_count * _WGSL_debug.BUF_ENTRY_SIZE;\n    this.buf_unit_size_bytes = () => Uint32Array.BYTES_PER_ELEMENT * this.buf_unit_size();\n    this.bindgroup_num = bindgroup_num;\n    this.buf_unit_entries_count = buf_unit_entries_count === void 0 ? _WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT : buf_unit_entries_count;\n    this.record = new Array();\n    this.pass_n = 0;\n  }\n  set_output(output) {\n    output.attach(this);\n    this.output = output;\n  }\n  add_shader(src, active) {\n    if (active) {\n      if (src.search(/^[ \\t]*dbg_init/m) < 0) {\n        alert(\"your shader does not contain any dbg_init() call, debug will not work properly\");\n      }\n    }\n    var debug_src = active ? this.shader_active() : _WGSL_debug.SHADER_INACTIVE;\n    this.marks = new Array();\n    const dbgm_calls = src.matchAll(/^[ \\t]*dbg_[uif]?32m[ \\t]*\\([ \\t]*(?<value>[0-9]+)[^;]*;[ \\t]*(\\/\\/|\\/\\*)(?<comment>.*)/mg);\n    for (const call of dbgm_calls) {\n      const value = Number(call.groups[\"value\"]);\n      const comment = call.groups[\"comment\"].trim();\n      this.marks[value] = comment;\n    }\n    console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`);\n    return debug_src + \"\\n\" + src;\n  }\n  setup(device, unit_count) {\n    console.log(\"WGSL_debug setup\");\n    this.device = device;\n    this.unit_count = unit_count;\n    this.buf_size = _WGSL_debug.BUF_HEADER_SIZE_BYTES + unit_count * this.buf_unit_size_bytes();\n    console.log(`WGSL_debug unit_count=${unit_count} buf_size=${this.buf_size}`);\n    if (this.buf) {\n      this.buf.destroy();\n    }\n    this.buf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n    if (this.dstbuf) {\n      this.dstbuf.destroy();\n    }\n    this.dstbuf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n    this.record = new Array();\n    this.pass_n = 0;\n    if (this.output) {\n      this.output.reset();\n    } else {\n      console.log(`WGSL_debug output format: <debug_header>\n<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`);\n    }\n  }\n  create_bindgroup(pipeline) {\n    this.bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(this.bindgroup_num),\n      entries: [{ binding: 0, resource: { buffer: this.buf } }]\n    });\n  }\n  set_bindgroup(pass) {\n    pass.setBindGroup(this.bindgroup_num, this.bindgroup);\n  }\n  fetch(cmd) {\n    cmd.copyBufferToBuffer(this.buf, 0, this.dstbuf, 0, this.buf_size);\n  }\n  async process(cb_data) {\n    await this.dstbuf.mapAsync(GPUMapMode.READ);\n    const buf = this.dstbuf.getMappedRange();\n    const buf_u32 = new Uint32Array(buf);\n    const buf_i32 = new Int32Array(buf);\n    const buf_f32 = new Float32Array(buf);\n    var pass_data;\n    this.hang_detect(\"reset\");\n    pass_data = Array.from(Array(this.unit_count), () => new Array());\n    for (var uid = 0; uid < this.unit_count; uid += 1) {\n      if (this.hang_detect(\"process\")) {\n        break;\n      }\n      const unit_off = _WGSL_debug.BUF_HEADER_SIZE + uid * this.buf_unit_size();\n      const entry_count = buf_u32[unit_off];\n      if (entry_count > 0) {\n        if (entry_count > this.buf_unit_entries_count) {\n          console.warn(`WGSL debug: ${entry_count} debug calls where made from unit_id=${uid}, but only the first ${this.buf_unit_entries_count} where recorded\nConsider increasing buf_unit_entries_count.`);\n        }\n        for (var entry = 0; entry < Math.min(entry_count, this.buf_unit_entries_count); entry++) {\n          const entry_off = unit_off + _WGSL_debug.BUF_UNIT_HEADER_SIZE + entry * _WGSL_debug.BUF_ENTRY_SIZE;\n          const type = buf_u32[entry_off];\n          var value = -1;\n          if (type == _WGSL_debug.BUF_ENTRY_TYPE_U32) {\n            value = buf_u32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_I32) {\n            value = buf_i32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_F32) {\n            value = buf_f32[entry_off + 1];\n          }\n          var mark = buf_u32[entry_off + 2];\n          pass_data[uid].push({\n            value,\n            type,\n            mark\n          });\n        }\n      }\n    }\n    this.record.push(pass_data);\n    var console_log = true;\n    if (this.output) {\n      console_log = false;\n      this.output.update();\n    }\n    if (cb_data) {\n      console_log = cb_data(this.pass_n, pass_data, this.record);\n    }\n    if (console_log) {\n      console.log(`WGSL_debug ${buf_u32.slice(0, _WGSL_debug.BUF_HEADER_SIZE).toString()}`);\n      var s = \"\";\n      pass_data.forEach((entries, uid2) => {\n        s += `${uid2} [${entries.length}] ${entries}\n`;\n      });\n      console.log(s);\n    }\n    this.dstbuf.unmap();\n    this.pass_n++;\n  }\n  clear_processed() {\n    this.record.forEach((pass) => {\n      pass.forEach((entries) => {\n        entries.forEach((entry) => {\n          entry.processed = false;\n        });\n      });\n    });\n  }\n  hang_detect(current_op, resolution) {\n    if (current_op != this.hang_detect_op) {\n      this.hang_detect_op = current_op;\n      this.hang_detect_start = Date.now();\n      this.hang_detect_counter = 0;\n      this.hang_detect_resolution = resolution ? resolution : _WGSL_debug.HANG_DETECT_RESOLUTION;\n    } else {\n      this.hang_detect_counter++;\n      if (this.hang_detect_counter % this.hang_detect_resolution == 0) {\n        const now = Date.now();\n        if (now - this.hang_detect_start > _WGSL_debug.HANG_DETECT_LIMIT) {\n          console.warn(`WGSL_debug hang detected in '${current_op}' after ${this.hang_detect_counter} iterations (${_WGSL_debug.HANG_DETECT_LIMIT}ms), interrupting operation`);\n          this.hang_detect_op = null;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\nlet WGSL_debug = _WGSL_debug;\nWGSL_debug.BUF_HEADER_SIZE = 16;\nWGSL_debug.BUF_HEADER_SIZE_BYTES = Uint32Array.BYTES_PER_ELEMENT * _WGSL_debug.BUF_HEADER_SIZE;\nWGSL_debug.BUF_UNIT_HEADER_SIZE = 1;\nWGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT = 20;\nWGSL_debug.BUF_ENTRY_SIZE = 3;\nWGSL_debug.BUF_ENTRY_TYPE_U32 = 1;\nWGSL_debug.BUF_ENTRY_TYPE_I32 = 2;\nWGSL_debug.BUF_ENTRY_TYPE_F32 = 3;\nWGSL_debug.BUF_ENTRY_MARK_UNSET = 999999;\nWGSL_debug.HANG_DETECT_LIMIT = 500;\nWGSL_debug.HANG_DETECT_RESOLUTION = 100;\nWGSL_debug.SHADER_INACTIVE = `fn dbg_init(unit_id: u32) {}\n\nfn dbg_u32(val: u32) {}\nfn dbg_i32(val: i32) {}\nfn dbg_f32(val: f32) {}\nfn dbg_32(val: u32, vtype: u32) {}\n\nfn dbg_u32m(mark: i32, val: u32) {}\nfn dbg_i32m(mark: i32, val: i32) {}\nfn dbg_f32m(mark: i32, val: f32) {}\nfn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;\nclass WGSL_debug_output {\n  constructor() {\n  }\n  attach(debug) {\n    console.log(\"WGSL_debug output attach\");\n    this.debug = debug;\n  }\n}\nexport { WGSL_debug, WGSL_debug_output };\n//# sourceMappingURL=wgsl-debug.es.js.map\n","/* wgsl-debug-table - Extension for wgsl-debug to display debugging data in HTML table\n * 2022, Laurent Ghigonis <ooookiwi@gmail.com> */\n\nimport { WGSL_debug, WGSL_debug_output } from 'wgsl-debug'\n\n/* html table column informations */\ntype html_col_info = {\n\tmaxlen: number;\t\t// maximum len for text in this column\n\tmark: number;\t\t// mark number in this column\n\tdirty_maxlen: boolean;\t// maxlen has been changed\n\twidth: number;\t\t// width in pixel of this column\n}\n\ntype WGSL_debug_table_conf = {\n\tselected_pass: number;\t// currently selected pass\n\tpass_range: number;\t// number of other pass we should display in same cell\n\tlive: boolean;\t\t// live mode active\n}\n\nexport class WGSL_debug_table extends WGSL_debug_output {\n\tprivate static readonly COL_WIDTH_ADJUST = 3;\n\tprivate static readonly MIN_UPDATE_INTERVAL = 100; // ms\n\tprivate conf: WGSL_debug_table_conf;\n\tprivate scroll: HTMLTableElement;\n\tprivate table: HTMLTableElement;\n\tprivate timeline: HTMLInputElement;\n\tprivate timelineval: HTMLInputElement;\n\tprivate passcount: HTMLInputElement;\n\tprivate timelinelive: HTMLInputElement;\n\tprivate passrange: HTMLInputElement;\n\tprivate row_height: number;\t\t// calculated row height\n\tprivate col: Array<html_col_info>;\t// informations for each table columns\n\tprivate last_update: number;\t\t// time of last update\n\tprivate update_timeout: number;\t\t// delayed update timeout, to avoid updating table too fast\n\tprivate processed: Array<boolean>;\t// processing state of each pass, to avoid reprocess passes\n\n\tpublic constructor(output_elm: string) {\n\t\tsuper();\n\t\tthis.conf = <WGSL_debug_table_conf> {\n\t\t\tselected_pass: 0,\n\t\t\tpass_range: 0,\n\t\t\tlive: false,\n\t\t\tdirty: false,\n\t\t};\n\n\t\tconst scroll_elm = output_elm + \"-scroll\";\n\t\tconst table_elm = output_elm + \"-table\";\n\t\tconst timeline_elm = output_elm + \"-timeline\";\n\t\tconst timelineval_elm = output_elm + \"-timelineval\";\n\t\tconst passcount_elm = output_elm + \"-passcount\";\n\t\tconst timelinelive_elm = output_elm + \"-timelinelive\";\n\t\tconst passrange_elm = output_elm + \"-passrange\";\n\t\tconst elm = <HTMLTableElement>document.getElementById(output_elm);\n\t\tif (!elm) {\n\t\t\tconsole.warn(`WGSL_debug: could not find debug output element id : '${output_elm}`);\n\t\t\treturn;\n\t\t}\n\n\t\t/* inject the table object and input controls */\n\t\telm.innerHTML = `\n<div class=\"debug-output-controls\">\n\tpass&nbsp;&nbsp;\n\t<input type=\"number\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timelineval_elm}\"/> &#xb1;\n\t<input type=\"number\" min=\"0\" max=\"60\" value=\"0\" step=\"1\" id=\"${passrange_elm}\"/> /\n\t<span id=\"${passcount_elm}\"></span>\n\t<input type=\"range\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timeline_elm}\" class=\"debug-output-timeline\"/>\n\t<label><input type=\"checkbox\" checked=1 id=\"${timelinelive_elm}\" />live</label>\n</div>\n<div id=\"${scroll_elm}\" class=\"debug-output-table\">\n\t<table id=\"${table_elm}\">\n\t</table>\n<div>\n`;\n\t\tthis.scroll = <HTMLTableElement>document.getElementById(scroll_elm);\n\t\tthis.table = <HTMLTableElement>document.getElementById(table_elm);\n\t\tthis.timeline = <HTMLInputElement>document.getElementById(timeline_elm);\n\t\tthis.timelineval = <HTMLInputElement>document.getElementById(timelineval_elm);\n\t\tthis.passcount = <HTMLInputElement>document.getElementById(passcount_elm);\n\t\tthis.timelinelive = <HTMLInputElement>document.getElementById(timelinelive_elm);\n\t\tthis.passrange = <HTMLInputElement>document.getElementById(passrange_elm);\n\n\t\t/* add javascript listeners */\n\t\tconst table_scroll = (_: Event) => {\n            //console.log(\"table_scroll\");\n\t\t\tthis.update();\n\t\t};\n\t\tconst timeline_input = (e: Event) => {\n            //console.log(\"timeline_input\");\n\t\t\tthis.conf.selected_pass = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.conf.live = false;\n\t\t\tthis.update();\n\t\t};\n\t\tconst timelineval_input = (e: Event) => {\n            //console.log(\"timelineval_input\");\n\t\t\tthis.conf.selected_pass = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.conf.live = false;\n\t\t\tthis.update();\n\t\t};\n\t\tconst timelinelive_click = (e: Event) => {\n            //console.log(\"timelinelive_click\");\n\t\t\tthis.conf.live = (e.target as HTMLInputElement).checked;\n\t\t\tthis.update();\n\t\t};\n\t\tconst passrange_input = (e: Event) => {\n            //console.log(\"passrange_input\");\n\t\t\tthis.conf.pass_range = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.row_height = 0;\n\t\t\tthis.debug.clear_processed();\n\t\t\tthis.reset();\n\t\t\tthis.update();\n\t\t};\n\t\tthis.scroll.addEventListener('scroll', table_scroll);\n\t\tthis.timeline.addEventListener('input', timeline_input);\n\t\tthis.timelineval.addEventListener('input', timelineval_input);\n\t\tthis.timelinelive.addEventListener('click', timelinelive_click);\n\t\tthis.passrange.addEventListener('input', passrange_input);\n\n\t\t/* append CSS */\n\t\tvar style = document.createElement('style');\n\t\tstyle.innerHTML = `\n#${timelineval_elm} { width: 5em; }\n#${passrange_elm} { width: 3em; }\n`;\n\t\tdocument.head.appendChild(style);\n\n\t\t/* initialize view */\n\t\tthis.row_height = 0; // row_height is slow to compute\n\t\tthis.reset();\n\t}\n\n\tpublic reset() {\n\t\t//console.log(\"WGSL_debug_table reset\");\n\t\tif (!this.table) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* reset state */\n\t\tthis.col = new Array();\n\t\tthis.processed = new Array();\n\n\t\t/* reset configuration */\n\t\tthis.conf.selected_pass = 0;\n\t\tthis.conf.live = true;\n\n\t\t/* reset table */\n\t\tthis._reset_table();\n\n\t\t/* update controls */\n\t\tthis.update();\n\t}\n\n\tprivate _reset_table() {\n\t\tthis.table.innerHTML = \"\";\n\t\tvar rowh = this.table.createTHead();\n\t\tvar cellh = document.createElement(\"th\");\n\t\tcellh.innerText = `uid`;\n\t\trowh.appendChild(cellh);\n\t}\n\n\tpublic update() {\n\t\tif (!this.table || !this.debug) {\n\t\t\treturn;\n\t\t}\n\t\twhile (this.processed.length < this.debug.record.length) {\n\t\t\tthis.processed.push(false);\n\t\t}\n\t\tif (window.getComputedStyle(this.table).visibility == \"hidden\") {\n\t\t\treturn;\n\t\t}\n\t\tconst now = Date.now();\n\t\tif (this.update_timeout\n                || (this.last_update && now - this.last_update < WGSL_debug_table.MIN_UPDATE_INTERVAL)) {\n\t\t\tif (!this.update_timeout) {\n\t\t\t\tthis.update_timeout = setTimeout(() => {\n\t\t\t\t\tthis.update_timeout = null;\n                    this.last_update = null;\n\t\t\t\t\tthis.update();\n\t\t\t\t}, WGSL_debug_table.MIN_UPDATE_INTERVAL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.debug.hang_detect(\"reset\");\n\t\t//console.log(`WGSL_debug_table update ${now - this.last_update}`);\n\t\tthis.last_update = now;\n\n\t\tconst conf = this.conf;\n\t\tconst debug = this.debug;\n\t\tconst thead = this.table.tHead;\n\n\t\t/*\n\t\t * update controls\n\t\t */\n\n\t\t/* live mode needs live updating */\n\t\tif (conf.live == true) {\n\t\t\tconf.selected_pass = debug.pass_n;\n\t\t}\n\n\t\tthis.timelineval.max = debug.pass_n.toString();\n\t\tthis.timelineval.value = conf.selected_pass.toString();\n\t\tthis.passcount.innerText = debug.pass_n.toString();\n\t\tthis.timeline.max = debug.pass_n.toString();\n\t\tthis.timeline.value = conf.selected_pass.toString();\n\t\tthis.timelinelive.checked = conf.live;\n\n\t\t/*\n\t\t * get selected pass\n\t\t */\n\n\t\tconst pass = debug.record[conf.selected_pass-1];\n\t\tif (!pass) {\n\t\t\tconsole.log(`table update no pass selected_pass=${conf.selected_pass} pass_n=${debug.pass_n} recordlen=${debug.record.length}`);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * create all the necessary rows\n\t\t */\n\n\t\tif (this.table.rows.length < pass.length) {\n\t\t\tconsole.log(`table update create_rows ${this.table.rows.length} to ${pass.length}`);\n\t\t\tif (this.table.tBodies.length == 0) {\n\t\t\t\tthis.table.createTBody();\n\t\t\t}\n\t\t\tconst celltext_empty = Array(1+conf.pass_range*2).fill(\"0\").join(\"<br/>\"); // empty string with correct height\n            console.log(`table update create_rows celltext_empty=${celltext_empty}`);\n\t\t\tvar rows = \"\"\n\t\t\tfor (var n = this.table.rows.length; n < pass.length; n++) {\n\t\t\t\trows += \"<tr><th>\"+n.toString()+\"</th><td>\"+celltext_empty+\"</td></tr>\\n\";\n\t\t\t}\n\t\t\tthis.table.tBodies[0].innerHTML += rows;\n\t\t\tconsole.log(`table update create_rows trigger`);\n            this.table.rows[0].cells[1].innerHTML = celltext_empty; // trigger table cell size calculation\n\t\t\tconsole.log(`table update create_rows done`);\n\t\t}\n\n\t\t/*\n\t\t * identify visible rows\n\t\t */\n\n\t\tif (!this.row_height) {\n\t\t\tconsole.log(\"table update get first cell\");\n\t\t\tconst firstcell = this.table.rows[0].cells[1];\n\t\t\t/* get first cell height */\n\t\t\tconsole.log(\"table update get first cell style\");\n\t\t\tconst style = window.getComputedStyle(firstcell);\n\t\t\tconsole.log(\"table update calculate row_height\");\n\t\t\tthis.row_height = Number(style.height.replace('px',''))\n\t\t\t\t+ Number(style.paddingTop.replace('px',''))\n\t\t\t\t+ Number(style.paddingBottom.replace('px',''));\n\t\t\tconsole.log(`WGSL_debug_table setting row_height=${this.row_height}`);\n\t\t}\n\t\t//console.log(\"table update compute visible\");\n\t\tconst scrolltop = this.scroll.scrollTop;\n\t\tconst table_y_visible = [ scrolltop,\n\t\t      \t\t\t  scrolltop + this.scroll.clientHeight ];\n\t\tconst row_visible = [ Math.floor(table_y_visible[0] / this.row_height),\n\t\t\t\t      Math.min(Math.ceil(table_y_visible[1] / this.row_height) + 1, pass.length) ];\n\n\t\t/*\n\t\t * update table columns\n\t\t */\n\n\t\t/* process pass */\n\t\t//console.log(`WGSL_debug_table update process_pass`);\n\t\tif (!this.processed[this.conf.selected_pass-1]) {\n\t\t\tpass.every((entries) => {\n\t\t\t\tif (this.debug.hang_detect(\"table update process_pass\")) {\n\t\t\t\t\treturn false; // break\n\t\t\t\t}\n\t\t\t\tvar col_n = 0; // current column position\n\t\t\t\t/* process cells */\n\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\tif (entry.processed) {\n\t\t\t\t\t\treturn; // continue\n\t\t\t\t\t}\n\t\t\t\t\t/* get entry value characters length */\n\t\t\t\t\t/* XXX this needs to be optimised: sampling ? float char len in math only ?\n\t\t\t\t\t * XXX sampling: optimise by doing this not all the time, especially when we already have parsed many passes */\n\t\t\t\t\tvar len = entry.value.toString().length + WGSL_debug_table.COL_WIDTH_ADJUST;\n\t\t\t\t\tif (this.conf.pass_range > 0) {\n\t\t\t\t\t\tlen += 2; // we will display '*' around the current value\n\t\t\t\t\t}\n\t\t\t\t\t/* find the column where to place this entry\n\t\t\t\t\t * first column with the corresponding mark will be used */\n\t\t\t\t\tfor (var col_ins = col_n ; ; col_ins++) {\n\t\t\t\t\t\t/* mark not found, insert column at current position */\n\t\t\t\t\t\tif (col_ins == this.col.length) {\n\t\t\t\t\t\t\tvar cellh = document.createElement(\"th\");\n\t\t\t\t\t\t\tif (entry.mark != WGSL_debug.BUF_ENTRY_MARK_UNSET) {\n\t\t\t\t\t\t\t\tif (debug.marks[entry.mark]) {\n\t\t\t\t\t\t\t\t\tcellh.innerText = debug.marks[entry.mark];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcellh.innerText = entry.mark.toString();;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcellh.innerText = \"d\"+col_n.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthead.insertBefore(cellh, thead.children[col_n].nextSibling);\n\t\t\t\t\t\t\tconst col: html_col_info = {\n\t\t\t\t\t\t\t\tmaxlen: len,\n\t\t\t\t\t\t\t\tmark: entry.mark,\n\t\t\t\t\t\t\t\tdirty_maxlen: true,\n\t\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.col.splice(col_n, 0, col); // insert\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* mark found, use this column */\n\t\t\t\t\t\tif (this.col[col_ins].mark == entry.mark) {\n\t\t\t\t\t\t\tcol_n = col_ins;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* check if we need to update column maxlen */\n\t\t\t\t\tif (len > this.col[col_n].maxlen) {\n\t\t\t\t\t\tthis.col[col_n].maxlen = len;\n\t\t\t\t\t\tthis.col[col_n].dirty_maxlen = true;\n\t\t\t\t\t}\n\t\t\t\t\t/* move to next table column */\n\t\t\t\t\tcol_n++;\n\t\t\t\t\tentry.processed = true;\n\t\t\t\t});\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tthis.processed[this.conf.selected_pass-1] = true;\n\t\t}\n\n\t\t/* update header columns width and calculate visible columns */\n\t\t//console.log(`WGSL_debug_table update header columns`);\n\t\tconst table_x_visible = [ this.scroll.scrollLeft,\n\t\t\t\t\t  this.scroll.scrollLeft + this.scroll.clientWidth ];\n\t\tvar col_offsetx = 0;\n\t\tvar col_visible = [ 0, this.col.length ];\n\t\tthis.col.every((col, col_n) => {\n\t\t\tif (this.debug.hang_detect(\"table update header columns\", 1)) {\n\t\t\t\treturn false; // break\n\t\t\t}\n\t\t\tif (col_offsetx < table_x_visible[0]) {\n\t\t\t\tcol_visible[0] = col_n;\n\t\t\t}\n\t\t\tif (col.dirty_maxlen) {\n\t\t\t\tconst cellh = <HTMLElement>thead.children[col_n+1];\n\t\t\t\tconst s = `min-width: ${col.maxlen}ex;`;\n\t\t\t\tcellh.setAttribute(\"style\", s);\n\t\t\t\tconst style = window.getComputedStyle(cellh);\n\t\t\t\tcol.width = Number(style.width.replace('px',''));\n\t\t\t}\n\t\t\tcol_offsetx += col.width;\n\t\t\tif (col_offsetx < table_x_visible[1]) {\n\t\t\t\tcol_visible[1] = col_n + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\t/*console.log(`WGSL_debug_table row_height=${this.row_height}\ntable_x_visible=${table_x_visible} table_y_visible=${table_y_visible}\ncol_visible=${col_visible}\nrow_visible=${row_visible}\npass.length=${pass.length}\nthis.col.length=${this.col.length}`);*/\n\n\t\t/*\n\t\t * update table content, only the cells that are visible\n\t\t */\n\n\t\t// XXX in case of same pass, only update data that was not visible before\n\t\t// XXX eg. in case on scroll\n\n\t\t// XXX in case of scroll, prefetch in same direction\n\n\t\tfor (var uid = row_visible[0]; uid < row_visible[1]; uid++) {\n\t\t\tif (this.debug.hang_detect(\"table update content\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst entries = pass[uid];\n\t\t\tconst row = this.table.rows[uid];\n\t\t\tvar col_n = 0; // current column position\n\t\t\tfor (var entry_n = col_visible[0]; entry_n < col_visible[1]; entry_n++) {\n\t\t\t\tconst entry = entries[entry_n];\n\t\t\t\tif (!entry) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* find which column to use for this entry */\n\t\t\t\twhile (entry.mark != this.col[col_n].mark) {\n\t\t\t\t\tcol_n++;\n\t\t\t\t\tif (col_n == this.col.length) {\n\t\t\t\t\t\t/* should never happend */\n\t\t\t\t\t\tconsole.warn(`WGSL_debug update html table content: did not find column mark for entry at uid=${uid} entry_n=${entry_n}`);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* insert or reuse cell */\n\t\t\t\twhile (!row.cells[col_n+1]) {\n\t\t\t\t\trow.insertCell(-1);\n\t\t\t\t}\n\t\t\t\tconst cell = row.cells[col_n+1];\n\t\t\t\t/* set cell content */\n\t\t\t\tvar s = \"\";\n\t\t\t\tif (conf.pass_range == 0) {\n\t\t\t\t\ts = entry.value.toString();\n\t\t\t\t} else {\n\t\t\t\t\tconst ctx_center = Math.max(conf.pass_range, Math.min(conf.selected_pass - 1, debug.record.length - 1 - conf.pass_range));\n\t\t\t\t\tconst ctx_first = ctx_center-conf.pass_range;\n\t\t\t\t\tconst ctx_last = ctx_center+conf.pass_range;\n\t\t\t\t\tfor (var ctx_n = ctx_first; ctx_n <= ctx_last; ctx_n++) {\n\t\t\t\t\t\tif (ctx_n == conf.selected_pass - 1) {\n\t\t\t\t\t\t\ts += \"*\" + entry.value + \"*\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst ctx_pass = debug.record[ctx_n];\n\t\t\t\t\t\t\ts += (ctx_pass && entry_n < ctx_pass[uid].length) ? ctx_pass[uid][entry_n].value : \"-\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx_n < ctx_last) {\n\t\t\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcell.innerText = s;\n\t\t\t\t/* move to next table cell */\n\t\t\t\tcol_n++;\n\t\t\t};\n\t\t};\n\t}\n\n}\n"],"names":[],"mappings":"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"}