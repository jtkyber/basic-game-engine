{"version":3,"file":"wgsl-debug-table.umd.js","sources":["../../dist/wgsl-debug.es.js","../wgsl-debug-table.ts"],"sourcesContent":["const _WGSL_debug = class {\n  constructor(bindgroup_num, buf_unit_entries_count) {\n    this.shader_active = () => `@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;\n\nvar<private> _dbg_unit: u32;\n\nfn dbg_init(uid: u32) {\n\t/* initialize debug unit for this uid */\n\t_dbg_unit = ${_WGSL_debug.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;\n\t_dbg[_dbg_unit] = 0u; // entries count\n}\n\nfn dbg_32m(mark: i32, val: u32, vtype: i32) {\n\t/* limit entries count, but still store the total number of calls */\n\tvar entry_count = _dbg[_dbg_unit];\n\t_dbg[_dbg_unit] = entry_count + 1u;\n\tif (entry_count == ${this.buf_unit_entries_count}u) {\n\t\treturn;\n\t}\n\n\t/* store data in a new debug unit entry */\n\tvar entry_off = _dbg_unit + 1u + entry_count * ${_WGSL_debug.BUF_ENTRY_SIZE}u;\n\t_dbg[entry_off] = u32(vtype);\n\t_dbg[entry_off + 1u] = val;\n\t_dbg[entry_off + 2u] = u32(mark);\n}\n\nfn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${_WGSL_debug.BUF_ENTRY_TYPE_U32}); }\nfn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_I32}); }\nfn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_F32}); }\nfn dbg_32(val: u32, vtype: i32) { dbg_32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val, vtype); }\nfn dbg_u32(val: u32) { dbg_u32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_i32(val: i32) { dbg_i32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_f32(val: f32) { dbg_f32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }`;\n    this.buf_unit_size = () => _WGSL_debug.BUF_UNIT_HEADER_SIZE + this.buf_unit_entries_count * _WGSL_debug.BUF_ENTRY_SIZE;\n    this.buf_unit_size_bytes = () => Uint32Array.BYTES_PER_ELEMENT * this.buf_unit_size();\n    this.bindgroup_num = bindgroup_num;\n    this.buf_unit_entries_count = buf_unit_entries_count === void 0 ? _WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT : buf_unit_entries_count;\n    this.record = new Array();\n    this.pass_n = 0;\n  }\n  set_output(output) {\n    output.attach(this);\n    this.output = output;\n  }\n  add_shader(src, active) {\n    if (active) {\n      if (src.search(/^[ \\t]*dbg_init/m) < 0) {\n        alert(\"your shader does not contain any dbg_init() call, debug will not work properly\");\n      }\n    }\n    var debug_src = active ? this.shader_active() : _WGSL_debug.SHADER_INACTIVE;\n    this.marks = new Array();\n    const dbgm_calls = src.matchAll(/^[ \\t]*dbg_[uif]?32m[ \\t]*\\([ \\t]*(?<value>[0-9]+)[^;]*;[ \\t]*(\\/\\/|\\/\\*)(?<comment>.*)/mg);\n    for (const call of dbgm_calls) {\n      const value = Number(call.groups[\"value\"]);\n      const comment = call.groups[\"comment\"].trim();\n      this.marks[value] = comment;\n    }\n    console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`);\n    return debug_src + \"\\n\" + src;\n  }\n  setup(device, unit_count) {\n    console.log(\"WGSL_debug setup\");\n    this.device = device;\n    this.unit_count = unit_count;\n    this.buf_size = _WGSL_debug.BUF_HEADER_SIZE_BYTES + unit_count * this.buf_unit_size_bytes();\n    console.log(`WGSL_debug unit_count=${unit_count} buf_size=${this.buf_size}`);\n    if (this.buf) {\n      this.buf.destroy();\n    }\n    this.buf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n    if (this.dstbuf) {\n      this.dstbuf.destroy();\n    }\n    this.dstbuf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n    this.record = new Array();\n    this.pass_n = 0;\n    if (this.output) {\n      this.output.reset();\n    } else {\n      console.log(`WGSL_debug output format: <debug_header>\n<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`);\n    }\n  }\n  create_bindgroup(pipeline) {\n    this.bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(this.bindgroup_num),\n      entries: [{ binding: 0, resource: { buffer: this.buf } }]\n    });\n  }\n  set_bindgroup(pass) {\n    pass.setBindGroup(this.bindgroup_num, this.bindgroup);\n  }\n  fetch(cmd) {\n    cmd.copyBufferToBuffer(this.buf, 0, this.dstbuf, 0, this.buf_size);\n  }\n  async process(cb_data) {\n    await this.dstbuf.mapAsync(GPUMapMode.READ);\n    const buf = this.dstbuf.getMappedRange();\n    const buf_u32 = new Uint32Array(buf);\n    const buf_i32 = new Int32Array(buf);\n    const buf_f32 = new Float32Array(buf);\n    var pass_data;\n    this.hang_detect(\"reset\");\n    pass_data = Array.from(Array(this.unit_count), () => new Array());\n    for (var uid = 0; uid < this.unit_count; uid += 1) {\n      if (this.hang_detect(\"process\")) {\n        break;\n      }\n      const unit_off = _WGSL_debug.BUF_HEADER_SIZE + uid * this.buf_unit_size();\n      const entry_count = buf_u32[unit_off];\n      if (entry_count > 0) {\n        if (entry_count > this.buf_unit_entries_count) {\n          console.warn(`WGSL debug: ${entry_count} debug calls where made from unit_id=${uid}, but only the first ${this.buf_unit_entries_count} where recorded\nConsider increasing buf_unit_entries_count.`);\n        }\n        for (var entry = 0; entry < Math.min(entry_count, this.buf_unit_entries_count); entry++) {\n          const entry_off = unit_off + _WGSL_debug.BUF_UNIT_HEADER_SIZE + entry * _WGSL_debug.BUF_ENTRY_SIZE;\n          const type = buf_u32[entry_off];\n          var value = -1;\n          if (type == _WGSL_debug.BUF_ENTRY_TYPE_U32) {\n            value = buf_u32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_I32) {\n            value = buf_i32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_F32) {\n            value = buf_f32[entry_off + 1];\n          }\n          var mark = buf_u32[entry_off + 2];\n          pass_data[uid].push({\n            value,\n            type,\n            mark\n          });\n        }\n      }\n    }\n    this.record.push(pass_data);\n    var console_log = true;\n    if (this.output) {\n      console_log = false;\n      this.output.update();\n    }\n    if (cb_data) {\n      console_log = cb_data(this.pass_n, pass_data, this.record);\n    }\n    if (console_log) {\n      console.log(`WGSL_debug ${buf_u32.slice(0, _WGSL_debug.BUF_HEADER_SIZE).toString()}`);\n      var s = \"\";\n      pass_data.forEach((entries, uid2) => {\n        s += `${uid2} [${entries.length}] ${entries}\n`;\n      });\n      console.log(s);\n    }\n    this.dstbuf.unmap();\n    this.pass_n++;\n  }\n  clear_processed() {\n    this.record.forEach((pass) => {\n      pass.forEach((entries) => {\n        entries.forEach((entry) => {\n          entry.processed = false;\n        });\n      });\n    });\n  }\n  hang_detect(current_op, resolution) {\n    if (current_op != this.hang_detect_op) {\n      this.hang_detect_op = current_op;\n      this.hang_detect_start = Date.now();\n      this.hang_detect_counter = 0;\n      this.hang_detect_resolution = resolution ? resolution : _WGSL_debug.HANG_DETECT_RESOLUTION;\n    } else {\n      this.hang_detect_counter++;\n      if (this.hang_detect_counter % this.hang_detect_resolution == 0) {\n        const now = Date.now();\n        if (now - this.hang_detect_start > _WGSL_debug.HANG_DETECT_LIMIT) {\n          console.warn(`WGSL_debug hang detected in '${current_op}' after ${this.hang_detect_counter} iterations (${_WGSL_debug.HANG_DETECT_LIMIT}ms), interrupting operation`);\n          this.hang_detect_op = null;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\nlet WGSL_debug = _WGSL_debug;\nWGSL_debug.BUF_HEADER_SIZE = 16;\nWGSL_debug.BUF_HEADER_SIZE_BYTES = Uint32Array.BYTES_PER_ELEMENT * _WGSL_debug.BUF_HEADER_SIZE;\nWGSL_debug.BUF_UNIT_HEADER_SIZE = 1;\nWGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT = 20;\nWGSL_debug.BUF_ENTRY_SIZE = 3;\nWGSL_debug.BUF_ENTRY_TYPE_U32 = 1;\nWGSL_debug.BUF_ENTRY_TYPE_I32 = 2;\nWGSL_debug.BUF_ENTRY_TYPE_F32 = 3;\nWGSL_debug.BUF_ENTRY_MARK_UNSET = 999999;\nWGSL_debug.HANG_DETECT_LIMIT = 500;\nWGSL_debug.HANG_DETECT_RESOLUTION = 100;\nWGSL_debug.SHADER_INACTIVE = `fn dbg_init(unit_id: u32) {}\n\nfn dbg_u32(val: u32) {}\nfn dbg_i32(val: i32) {}\nfn dbg_f32(val: f32) {}\nfn dbg_32(val: u32, vtype: u32) {}\n\nfn dbg_u32m(mark: i32, val: u32) {}\nfn dbg_i32m(mark: i32, val: i32) {}\nfn dbg_f32m(mark: i32, val: f32) {}\nfn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;\nclass WGSL_debug_output {\n  constructor() {\n  }\n  attach(debug) {\n    console.log(\"WGSL_debug output attach\");\n    this.debug = debug;\n  }\n}\nexport { WGSL_debug, WGSL_debug_output };\n//# sourceMappingURL=wgsl-debug.es.js.map\n","/* wgsl-debug-table - Extension for wgsl-debug to display debugging data in HTML table\n * 2022, Laurent Ghigonis <ooookiwi@gmail.com> */\n\nimport { WGSL_debug, WGSL_debug_output } from 'wgsl-debug'\n\n/* html table column informations */\ntype html_col_info = {\n\tmaxlen: number;\t\t// maximum len for text in this column\n\tmark: number;\t\t// mark number in this column\n\tdirty_maxlen: boolean;\t// maxlen has been changed\n\twidth: number;\t\t// width in pixel of this column\n}\n\ntype WGSL_debug_table_conf = {\n\tselected_pass: number;\t// currently selected pass\n\tpass_range: number;\t// number of other pass we should display in same cell\n\tlive: boolean;\t\t// live mode active\n}\n\nexport class WGSL_debug_table extends WGSL_debug_output {\n\tprivate static readonly COL_WIDTH_ADJUST = 3;\n\tprivate static readonly MIN_UPDATE_INTERVAL = 100; // ms\n\tprivate conf: WGSL_debug_table_conf;\n\tprivate scroll: HTMLTableElement;\n\tprivate table: HTMLTableElement;\n\tprivate timeline: HTMLInputElement;\n\tprivate timelineval: HTMLInputElement;\n\tprivate passcount: HTMLInputElement;\n\tprivate timelinelive: HTMLInputElement;\n\tprivate passrange: HTMLInputElement;\n\tprivate row_height: number;\t\t// calculated row height\n\tprivate col: Array<html_col_info>;\t// informations for each table columns\n\tprivate last_update: number;\t\t// time of last update\n\tprivate update_timeout: number;\t\t// delayed update timeout, to avoid updating table too fast\n\tprivate processed: Array<boolean>;\t// processing state of each pass, to avoid reprocess passes\n\n\tpublic constructor(output_elm: string) {\n\t\tsuper();\n\t\tthis.conf = <WGSL_debug_table_conf> {\n\t\t\tselected_pass: 0,\n\t\t\tpass_range: 0,\n\t\t\tlive: false,\n\t\t\tdirty: false,\n\t\t};\n\n\t\tconst scroll_elm = output_elm + \"-scroll\";\n\t\tconst table_elm = output_elm + \"-table\";\n\t\tconst timeline_elm = output_elm + \"-timeline\";\n\t\tconst timelineval_elm = output_elm + \"-timelineval\";\n\t\tconst passcount_elm = output_elm + \"-passcount\";\n\t\tconst timelinelive_elm = output_elm + \"-timelinelive\";\n\t\tconst passrange_elm = output_elm + \"-passrange\";\n\t\tconst elm = <HTMLTableElement>document.getElementById(output_elm);\n\t\tif (!elm) {\n\t\t\tconsole.warn(`WGSL_debug: could not find debug output element id : '${output_elm}`);\n\t\t\treturn;\n\t\t}\n\n\t\t/* inject the table object and input controls */\n\t\telm.innerHTML = `\n<div class=\"debug-output-controls\">\n\tpass&nbsp;&nbsp;\n\t<input type=\"number\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timelineval_elm}\"/> &#xb1;\n\t<input type=\"number\" min=\"0\" max=\"60\" value=\"0\" step=\"1\" id=\"${passrange_elm}\"/> /\n\t<span id=\"${passcount_elm}\"></span>\n\t<input type=\"range\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timeline_elm}\" class=\"debug-output-timeline\"/>\n\t<label><input type=\"checkbox\" checked=1 id=\"${timelinelive_elm}\" />live</label>\n</div>\n<div id=\"${scroll_elm}\" class=\"debug-output-table\">\n\t<table id=\"${table_elm}\">\n\t</table>\n<div>\n`;\n\t\tthis.scroll = <HTMLTableElement>document.getElementById(scroll_elm);\n\t\tthis.table = <HTMLTableElement>document.getElementById(table_elm);\n\t\tthis.timeline = <HTMLInputElement>document.getElementById(timeline_elm);\n\t\tthis.timelineval = <HTMLInputElement>document.getElementById(timelineval_elm);\n\t\tthis.passcount = <HTMLInputElement>document.getElementById(passcount_elm);\n\t\tthis.timelinelive = <HTMLInputElement>document.getElementById(timelinelive_elm);\n\t\tthis.passrange = <HTMLInputElement>document.getElementById(passrange_elm);\n\n\t\t/* add javascript listeners */\n\t\tconst table_scroll = (_: Event) => {\n            //console.log(\"table_scroll\");\n\t\t\tthis.update();\n\t\t};\n\t\tconst timeline_input = (e: Event) => {\n            //console.log(\"timeline_input\");\n\t\t\tthis.conf.selected_pass = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.conf.live = false;\n\t\t\tthis.update();\n\t\t};\n\t\tconst timelineval_input = (e: Event) => {\n            //console.log(\"timelineval_input\");\n\t\t\tthis.conf.selected_pass = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.conf.live = false;\n\t\t\tthis.update();\n\t\t};\n\t\tconst timelinelive_click = (e: Event) => {\n            //console.log(\"timelinelive_click\");\n\t\t\tthis.conf.live = (e.target as HTMLInputElement).checked;\n\t\t\tthis.update();\n\t\t};\n\t\tconst passrange_input = (e: Event) => {\n            //console.log(\"passrange_input\");\n\t\t\tthis.conf.pass_range = Number((e.target as HTMLInputElement).value);\n\t\t\tthis.row_height = 0;\n\t\t\tthis.debug.clear_processed();\n\t\t\tthis.reset();\n\t\t\tthis.update();\n\t\t};\n\t\tthis.scroll.addEventListener('scroll', table_scroll);\n\t\tthis.timeline.addEventListener('input', timeline_input);\n\t\tthis.timelineval.addEventListener('input', timelineval_input);\n\t\tthis.timelinelive.addEventListener('click', timelinelive_click);\n\t\tthis.passrange.addEventListener('input', passrange_input);\n\n\t\t/* append CSS */\n\t\tvar style = document.createElement('style');\n\t\tstyle.innerHTML = `\n#${timelineval_elm} { width: 5em; }\n#${passrange_elm} { width: 3em; }\n`;\n\t\tdocument.head.appendChild(style);\n\n\t\t/* initialize view */\n\t\tthis.row_height = 0; // row_height is slow to compute\n\t\tthis.reset();\n\t}\n\n\tpublic reset() {\n\t\t//console.log(\"WGSL_debug_table reset\");\n\t\tif (!this.table) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* reset state */\n\t\tthis.col = new Array();\n\t\tthis.processed = new Array();\n\n\t\t/* reset configuration */\n\t\tthis.conf.selected_pass = 0;\n\t\tthis.conf.live = true;\n\n\t\t/* reset table */\n\t\tthis._reset_table();\n\n\t\t/* update controls */\n\t\tthis.update();\n\t}\n\n\tprivate _reset_table() {\n\t\tthis.table.innerHTML = \"\";\n\t\tvar rowh = this.table.createTHead();\n\t\tvar cellh = document.createElement(\"th\");\n\t\tcellh.innerText = `uid`;\n\t\trowh.appendChild(cellh);\n\t}\n\n\tpublic update() {\n\t\tif (!this.table || !this.debug) {\n\t\t\treturn;\n\t\t}\n\t\twhile (this.processed.length < this.debug.record.length) {\n\t\t\tthis.processed.push(false);\n\t\t}\n\t\tif (window.getComputedStyle(this.table).visibility == \"hidden\") {\n\t\t\treturn;\n\t\t}\n\t\tconst now = Date.now();\n\t\tif (this.update_timeout\n                || (this.last_update && now - this.last_update < WGSL_debug_table.MIN_UPDATE_INTERVAL)) {\n\t\t\tif (!this.update_timeout) {\n\t\t\t\tthis.update_timeout = setTimeout(() => {\n\t\t\t\t\tthis.update_timeout = null;\n                    this.last_update = null;\n\t\t\t\t\tthis.update();\n\t\t\t\t}, WGSL_debug_table.MIN_UPDATE_INTERVAL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.debug.hang_detect(\"reset\");\n\t\t//console.log(`WGSL_debug_table update ${now - this.last_update}`);\n\t\tthis.last_update = now;\n\n\t\tconst conf = this.conf;\n\t\tconst debug = this.debug;\n\t\tconst thead = this.table.tHead;\n\n\t\t/*\n\t\t * update controls\n\t\t */\n\n\t\t/* live mode needs live updating */\n\t\tif (conf.live == true) {\n\t\t\tconf.selected_pass = debug.pass_n;\n\t\t}\n\n\t\tthis.timelineval.max = debug.pass_n.toString();\n\t\tthis.timelineval.value = conf.selected_pass.toString();\n\t\tthis.passcount.innerText = debug.pass_n.toString();\n\t\tthis.timeline.max = debug.pass_n.toString();\n\t\tthis.timeline.value = conf.selected_pass.toString();\n\t\tthis.timelinelive.checked = conf.live;\n\n\t\t/*\n\t\t * get selected pass\n\t\t */\n\n\t\tconst pass = debug.record[conf.selected_pass-1];\n\t\tif (!pass) {\n\t\t\tconsole.log(`table update no pass selected_pass=${conf.selected_pass} pass_n=${debug.pass_n} recordlen=${debug.record.length}`);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * create all the necessary rows\n\t\t */\n\n\t\tif (this.table.rows.length < pass.length) {\n\t\t\tconsole.log(`table update create_rows ${this.table.rows.length} to ${pass.length}`);\n\t\t\tif (this.table.tBodies.length == 0) {\n\t\t\t\tthis.table.createTBody();\n\t\t\t}\n\t\t\tconst celltext_empty = Array(1+conf.pass_range*2).fill(\"0\").join(\"<br/>\"); // empty string with correct height\n            console.log(`table update create_rows celltext_empty=${celltext_empty}`);\n\t\t\tvar rows = \"\"\n\t\t\tfor (var n = this.table.rows.length; n < pass.length; n++) {\n\t\t\t\trows += \"<tr><th>\"+n.toString()+\"</th><td>\"+celltext_empty+\"</td></tr>\\n\";\n\t\t\t}\n\t\t\tthis.table.tBodies[0].innerHTML += rows;\n\t\t\tconsole.log(`table update create_rows trigger`);\n            this.table.rows[0].cells[1].innerHTML = celltext_empty; // trigger table cell size calculation\n\t\t\tconsole.log(`table update create_rows done`);\n\t\t}\n\n\t\t/*\n\t\t * identify visible rows\n\t\t */\n\n\t\tif (!this.row_height) {\n\t\t\tconsole.log(\"table update get first cell\");\n\t\t\tconst firstcell = this.table.rows[0].cells[1];\n\t\t\t/* get first cell height */\n\t\t\tconsole.log(\"table update get first cell style\");\n\t\t\tconst style = window.getComputedStyle(firstcell);\n\t\t\tconsole.log(\"table update calculate row_height\");\n\t\t\tthis.row_height = Number(style.height.replace('px',''))\n\t\t\t\t+ Number(style.paddingTop.replace('px',''))\n\t\t\t\t+ Number(style.paddingBottom.replace('px',''));\n\t\t\tconsole.log(`WGSL_debug_table setting row_height=${this.row_height}`);\n\t\t}\n\t\t//console.log(\"table update compute visible\");\n\t\tconst scrolltop = this.scroll.scrollTop;\n\t\tconst table_y_visible = [ scrolltop,\n\t\t      \t\t\t  scrolltop + this.scroll.clientHeight ];\n\t\tconst row_visible = [ Math.floor(table_y_visible[0] / this.row_height),\n\t\t\t\t      Math.min(Math.ceil(table_y_visible[1] / this.row_height) + 1, pass.length) ];\n\n\t\t/*\n\t\t * update table columns\n\t\t */\n\n\t\t/* process pass */\n\t\t//console.log(`WGSL_debug_table update process_pass`);\n\t\tif (!this.processed[this.conf.selected_pass-1]) {\n\t\t\tpass.every((entries) => {\n\t\t\t\tif (this.debug.hang_detect(\"table update process_pass\")) {\n\t\t\t\t\treturn false; // break\n\t\t\t\t}\n\t\t\t\tvar col_n = 0; // current column position\n\t\t\t\t/* process cells */\n\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\tif (entry.processed) {\n\t\t\t\t\t\treturn; // continue\n\t\t\t\t\t}\n\t\t\t\t\t/* get entry value characters length */\n\t\t\t\t\t/* XXX this needs to be optimised: sampling ? float char len in math only ?\n\t\t\t\t\t * XXX sampling: optimise by doing this not all the time, especially when we already have parsed many passes */\n\t\t\t\t\tvar len = entry.value.toString().length + WGSL_debug_table.COL_WIDTH_ADJUST;\n\t\t\t\t\tif (this.conf.pass_range > 0) {\n\t\t\t\t\t\tlen += 2; // we will display '*' around the current value\n\t\t\t\t\t}\n\t\t\t\t\t/* find the column where to place this entry\n\t\t\t\t\t * first column with the corresponding mark will be used */\n\t\t\t\t\tfor (var col_ins = col_n ; ; col_ins++) {\n\t\t\t\t\t\t/* mark not found, insert column at current position */\n\t\t\t\t\t\tif (col_ins == this.col.length) {\n\t\t\t\t\t\t\tvar cellh = document.createElement(\"th\");\n\t\t\t\t\t\t\tif (entry.mark != WGSL_debug.BUF_ENTRY_MARK_UNSET) {\n\t\t\t\t\t\t\t\tif (debug.marks[entry.mark]) {\n\t\t\t\t\t\t\t\t\tcellh.innerText = debug.marks[entry.mark];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcellh.innerText = entry.mark.toString();;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcellh.innerText = \"d\"+col_n.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthead.insertBefore(cellh, thead.children[col_n].nextSibling);\n\t\t\t\t\t\t\tconst col: html_col_info = {\n\t\t\t\t\t\t\t\tmaxlen: len,\n\t\t\t\t\t\t\t\tmark: entry.mark,\n\t\t\t\t\t\t\t\tdirty_maxlen: true,\n\t\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.col.splice(col_n, 0, col); // insert\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* mark found, use this column */\n\t\t\t\t\t\tif (this.col[col_ins].mark == entry.mark) {\n\t\t\t\t\t\t\tcol_n = col_ins;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* check if we need to update column maxlen */\n\t\t\t\t\tif (len > this.col[col_n].maxlen) {\n\t\t\t\t\t\tthis.col[col_n].maxlen = len;\n\t\t\t\t\t\tthis.col[col_n].dirty_maxlen = true;\n\t\t\t\t\t}\n\t\t\t\t\t/* move to next table column */\n\t\t\t\t\tcol_n++;\n\t\t\t\t\tentry.processed = true;\n\t\t\t\t});\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tthis.processed[this.conf.selected_pass-1] = true;\n\t\t}\n\n\t\t/* update header columns width and calculate visible columns */\n\t\t//console.log(`WGSL_debug_table update header columns`);\n\t\tconst table_x_visible = [ this.scroll.scrollLeft,\n\t\t\t\t\t  this.scroll.scrollLeft + this.scroll.clientWidth ];\n\t\tvar col_offsetx = 0;\n\t\tvar col_visible = [ 0, this.col.length ];\n\t\tthis.col.every((col, col_n) => {\n\t\t\tif (this.debug.hang_detect(\"table update header columns\", 1)) {\n\t\t\t\treturn false; // break\n\t\t\t}\n\t\t\tif (col_offsetx < table_x_visible[0]) {\n\t\t\t\tcol_visible[0] = col_n;\n\t\t\t}\n\t\t\tif (col.dirty_maxlen) {\n\t\t\t\tconst cellh = <HTMLElement>thead.children[col_n+1];\n\t\t\t\tconst s = `min-width: ${col.maxlen}ex;`;\n\t\t\t\tcellh.setAttribute(\"style\", s);\n\t\t\t\tconst style = window.getComputedStyle(cellh);\n\t\t\t\tcol.width = Number(style.width.replace('px',''));\n\t\t\t}\n\t\t\tcol_offsetx += col.width;\n\t\t\tif (col_offsetx < table_x_visible[1]) {\n\t\t\t\tcol_visible[1] = col_n + 1;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\t/*console.log(`WGSL_debug_table row_height=${this.row_height}\ntable_x_visible=${table_x_visible} table_y_visible=${table_y_visible}\ncol_visible=${col_visible}\nrow_visible=${row_visible}\npass.length=${pass.length}\nthis.col.length=${this.col.length}`);*/\n\n\t\t/*\n\t\t * update table content, only the cells that are visible\n\t\t */\n\n\t\t// XXX in case of same pass, only update data that was not visible before\n\t\t// XXX eg. in case on scroll\n\n\t\t// XXX in case of scroll, prefetch in same direction\n\n\t\tfor (var uid = row_visible[0]; uid < row_visible[1]; uid++) {\n\t\t\tif (this.debug.hang_detect(\"table update content\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst entries = pass[uid];\n\t\t\tconst row = this.table.rows[uid];\n\t\t\tvar col_n = 0; // current column position\n\t\t\tfor (var entry_n = col_visible[0]; entry_n < col_visible[1]; entry_n++) {\n\t\t\t\tconst entry = entries[entry_n];\n\t\t\t\tif (!entry) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* find which column to use for this entry */\n\t\t\t\twhile (entry.mark != this.col[col_n].mark) {\n\t\t\t\t\tcol_n++;\n\t\t\t\t\tif (col_n == this.col.length) {\n\t\t\t\t\t\t/* should never happend */\n\t\t\t\t\t\tconsole.warn(`WGSL_debug update html table content: did not find column mark for entry at uid=${uid} entry_n=${entry_n}`);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* insert or reuse cell */\n\t\t\t\twhile (!row.cells[col_n+1]) {\n\t\t\t\t\trow.insertCell(-1);\n\t\t\t\t}\n\t\t\t\tconst cell = row.cells[col_n+1];\n\t\t\t\t/* set cell content */\n\t\t\t\tvar s = \"\";\n\t\t\t\tif (conf.pass_range == 0) {\n\t\t\t\t\ts = entry.value.toString();\n\t\t\t\t} else {\n\t\t\t\t\tconst ctx_center = Math.max(conf.pass_range, Math.min(conf.selected_pass - 1, debug.record.length - 1 - conf.pass_range));\n\t\t\t\t\tconst ctx_first = ctx_center-conf.pass_range;\n\t\t\t\t\tconst ctx_last = ctx_center+conf.pass_range;\n\t\t\t\t\tfor (var ctx_n = ctx_first; ctx_n <= ctx_last; ctx_n++) {\n\t\t\t\t\t\tif (ctx_n == conf.selected_pass - 1) {\n\t\t\t\t\t\t\ts += \"*\" + entry.value + \"*\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst ctx_pass = debug.record[ctx_n];\n\t\t\t\t\t\t\ts += (ctx_pass && entry_n < ctx_pass[uid].length) ? ctx_pass[uid][entry_n].value : \"-\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx_n < ctx_last) {\n\t\t\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcell.innerText = s;\n\t\t\t\t/* move to next table cell */\n\t\t\t\tcol_n++;\n\t\t\t};\n\t\t};\n\t}\n\n}\n"],"names":[],"mappings":"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"}