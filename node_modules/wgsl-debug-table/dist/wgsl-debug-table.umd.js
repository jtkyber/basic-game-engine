(function(y,s){typeof exports=="object"&&typeof module!="undefined"?s(exports):typeof define=="function"&&define.amd?define(["exports"],s):(y=typeof globalThis!="undefined"?globalThis:y||self,s(y["wgsl-debug-table"]={}))})(this,function(y){"use strict";const s=class{constructor(t,e){this.shader_active=()=>`@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;

var<private> _dbg_unit: u32;

fn dbg_init(uid: u32) {
	/* initialize debug unit for this uid */
	_dbg_unit = ${s.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;
	_dbg[_dbg_unit] = 0u; // entries count
}

fn dbg_32m(mark: i32, val: u32, vtype: i32) {
	/* limit entries count, but still store the total number of calls */
	var entry_count = _dbg[_dbg_unit];
	_dbg[_dbg_unit] = entry_count + 1u;
	if (entry_count == ${this.buf_unit_entries_count}u) {
		return;
	}

	/* store data in a new debug unit entry */
	var entry_off = _dbg_unit + 1u + entry_count * ${s.BUF_ENTRY_SIZE}u;
	_dbg[entry_off] = u32(vtype);
	_dbg[entry_off + 1u] = val;
	_dbg[entry_off + 2u] = u32(mark);
}

fn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${s.BUF_ENTRY_TYPE_U32}); }
fn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${s.BUF_ENTRY_TYPE_I32}); }
fn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${s.BUF_ENTRY_TYPE_F32}); }
fn dbg_32(val: u32, vtype: i32) { dbg_32m(${s.BUF_ENTRY_MARK_UNSET}, val, vtype); }
fn dbg_u32(val: u32) { dbg_u32m(${s.BUF_ENTRY_MARK_UNSET}, val); }
fn dbg_i32(val: i32) { dbg_i32m(${s.BUF_ENTRY_MARK_UNSET}, val); }
fn dbg_f32(val: f32) { dbg_f32m(${s.BUF_ENTRY_MARK_UNSET}, val); }`,this.buf_unit_size=()=>s.BUF_UNIT_HEADER_SIZE+this.buf_unit_entries_count*s.BUF_ENTRY_SIZE,this.buf_unit_size_bytes=()=>Uint32Array.BYTES_PER_ELEMENT*this.buf_unit_size(),this.bindgroup_num=t,this.buf_unit_entries_count=e===void 0?s.BUF_UNIT_ENTRIES_COUNT_DEFAULT:e,this.record=new Array,this.pass_n=0}set_output(t){t.attach(this),this.output=t}add_shader(t,e){e&&t.search(/^[ \t]*dbg_init/m)<0&&alert("your shader does not contain any dbg_init() call, debug will not work properly");var i=e?this.shader_active():s.SHADER_INACTIVE;this.marks=new Array;const f=t.matchAll(/^[ \t]*dbg_[uif]?32m[ \t]*\([ \t]*(?<value>[0-9]+)[^;]*;[ \t]*(\/\/|\/\*)(?<comment>.*)/mg);for(const l of f){const h=Number(l.groups.value),u=l.groups.comment.trim();this.marks[h]=u}return console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`),i+`
`+t}setup(t,e){console.log("WGSL_debug setup"),this.device=t,this.unit_count=e,this.buf_size=s.BUF_HEADER_SIZE_BYTES+e*this.buf_unit_size_bytes(),console.log(`WGSL_debug unit_count=${e} buf_size=${this.buf_size}`),this.buf&&this.buf.destroy(),this.buf=t.createBuffer({size:this.buf_size,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.dstbuf&&this.dstbuf.destroy(),this.dstbuf=t.createBuffer({size:this.buf_size,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.record=new Array,this.pass_n=0,this.output?this.output.reset():console.log(`WGSL_debug output format: <debug_header>
<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`)}create_bindgroup(t){this.bindgroup=this.device.createBindGroup({layout:t.getBindGroupLayout(this.bindgroup_num),entries:[{binding:0,resource:{buffer:this.buf}}]})}set_bindgroup(t){t.setBindGroup(this.bindgroup_num,this.bindgroup)}fetch(t){t.copyBufferToBuffer(this.buf,0,this.dstbuf,0,this.buf_size)}async process(t){await this.dstbuf.mapAsync(GPUMapMode.READ);const e=this.dstbuf.getMappedRange(),i=new Uint32Array(e),f=new Int32Array(e),l=new Float32Array(e);var h;this.hang_detect("reset"),h=Array.from(Array(this.unit_count),()=>new Array);for(var u=0;u<this.unit_count&&!this.hang_detect("process");u+=1){const g=s.BUF_HEADER_SIZE+u*this.buf_unit_size(),o=i[g];if(o>0){o>this.buf_unit_entries_count&&console.warn(`WGSL debug: ${o} debug calls where made from unit_id=${u}, but only the first ${this.buf_unit_entries_count} where recorded
Consider increasing buf_unit_entries_count.`);for(var b=0;b<Math.min(o,this.buf_unit_entries_count);b++){const _=g+s.BUF_UNIT_HEADER_SIZE+b*s.BUF_ENTRY_SIZE,a=i[_];var p=-1;a==s.BUF_ENTRY_TYPE_U32?p=i[_+1]:a==s.BUF_ENTRY_TYPE_I32?p=f[_+1]:a==s.BUF_ENTRY_TYPE_F32&&(p=l[_+1]);var S=i[_+2];h[u].push({value:p,type:a,mark:S})}}}this.record.push(h);var E=!0;if(this.output&&(E=!1,this.output.update()),t&&(E=t(this.pass_n,h,this.record)),E){console.log(`WGSL_debug ${i.slice(0,s.BUF_HEADER_SIZE).toString()}`);var v="";h.forEach((g,o)=>{v+=`${o} [${g.length}] ${g}
`}),console.log(v)}this.dstbuf.unmap(),this.pass_n++}clear_processed(){this.record.forEach(t=>{t.forEach(e=>{e.forEach(i=>{i.processed=!1})})})}hang_detect(t,e){if(t!=this.hang_detect_op)this.hang_detect_op=t,this.hang_detect_start=Date.now(),this.hang_detect_counter=0,this.hang_detect_resolution=e||s.HANG_DETECT_RESOLUTION;else if(this.hang_detect_counter++,this.hang_detect_counter%this.hang_detect_resolution==0&&Date.now()-this.hang_detect_start>s.HANG_DETECT_LIMIT)return console.warn(`WGSL_debug hang detected in '${t}' after ${this.hang_detect_counter} iterations (${s.HANG_DETECT_LIMIT}ms), interrupting operation`),this.hang_detect_op=null,!0;return!1}};let c=s;c.BUF_HEADER_SIZE=16,c.BUF_HEADER_SIZE_BYTES=Uint32Array.BYTES_PER_ELEMENT*s.BUF_HEADER_SIZE,c.BUF_UNIT_HEADER_SIZE=1,c.BUF_UNIT_ENTRIES_COUNT_DEFAULT=20,c.BUF_ENTRY_SIZE=3,c.BUF_ENTRY_TYPE_U32=1,c.BUF_ENTRY_TYPE_I32=2,c.BUF_ENTRY_TYPE_F32=3,c.BUF_ENTRY_MARK_UNSET=999999,c.HANG_DETECT_LIMIT=500,c.HANG_DETECT_RESOLUTION=100,c.SHADER_INACTIVE=`fn dbg_init(unit_id: u32) {}

fn dbg_u32(val: u32) {}
fn dbg_i32(val: i32) {}
fn dbg_f32(val: f32) {}
fn dbg_32(val: u32, vtype: u32) {}

fn dbg_u32m(mark: i32, val: u32) {}
fn dbg_i32m(mark: i32, val: i32) {}
fn dbg_f32m(mark: i32, val: f32) {}
fn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;class ${constructor(){}attach(e){console.log("WGSL_debug output attach"),this.debug=e}}const B=class extends ${constructor(t){super();this.conf={selected_pass:0,pass_range:0,live:!1,dirty:!1};const e=t+"-scroll",i=t+"-table",f=t+"-timeline",l=t+"-timelineval",h=t+"-passcount",u=t+"-timelinelive",b=t+"-passrange",p=document.getElementById(t);if(!p){console.warn(`WGSL_debug: could not find debug output element id : '${t}`);return}p.innerHTML=`
<div class="debug-output-controls">
	pass&nbsp;&nbsp;
	<input type="number" min="1" max="0" value="0" step="1" id="${l}"/> &#xb1;
	<input type="number" min="0" max="60" value="0" step="1" id="${b}"/> /
	<span id="${h}"></span>
	<input type="range" min="1" max="0" value="0" step="1" id="${f}" class="debug-output-timeline"/>
	<label><input type="checkbox" checked=1 id="${u}" />live</label>
</div>
<div id="${e}" class="debug-output-table">
	<table id="${i}">
	</table>
<div>
`,this.scroll=document.getElementById(e),this.table=document.getElementById(i),this.timeline=document.getElementById(f),this.timelineval=document.getElementById(l),this.passcount=document.getElementById(h),this.timelinelive=document.getElementById(u),this.passrange=document.getElementById(b);const S=a=>{this.update()},E=a=>{this.conf.selected_pass=Number(a.target.value),this.conf.live=!1,this.update()},v=a=>{this.conf.selected_pass=Number(a.target.value),this.conf.live=!1,this.update()},g=a=>{this.conf.live=a.target.checked,this.update()},o=a=>{this.conf.pass_range=Number(a.target.value),this.row_height=0,this.debug.clear_processed(),this.reset(),this.update()};this.scroll.addEventListener("scroll",S),this.timeline.addEventListener("input",E),this.timelineval.addEventListener("input",v),this.timelinelive.addEventListener("click",g),this.passrange.addEventListener("input",o);var _=document.createElement("style");_.innerHTML=`
#${l} { width: 5em; }
#${b} { width: 3em; }
`,document.head.appendChild(_),this.row_height=0,this.reset()}reset(){!this.table||(this.col=new Array,this.processed=new Array,this.conf.selected_pass=0,this.conf.live=!0,this._reset_table(),this.update())}_reset_table(){this.table.innerHTML="";var t=this.table.createTHead(),e=document.createElement("th");e.innerText="uid",t.appendChild(e)}update(){if(!this.table||!this.debug)return;for(;this.processed.length<this.debug.record.length;)this.processed.push(!1);if(window.getComputedStyle(this.table).visibility=="hidden")return;const t=Date.now();if(this.update_timeout||this.last_update&&t-this.last_update<B.MIN_UPDATE_INTERVAL){this.update_timeout||(this.update_timeout=setTimeout(()=>{this.update_timeout=null,this.last_update=null,this.update()},B.MIN_UPDATE_INTERVAL));return}this.debug.hang_detect("reset"),this.last_update=t;const e=this.conf,i=this.debug,f=this.table.tHead;e.live==!0&&(e.selected_pass=i.pass_n),this.timelineval.max=i.pass_n.toString(),this.timelineval.value=e.selected_pass.toString(),this.passcount.innerText=i.pass_n.toString(),this.timeline.max=i.pass_n.toString(),this.timeline.value=e.selected_pass.toString(),this.timelinelive.checked=e.live;const l=i.record[e.selected_pass-1];if(!l){console.log(`table update no pass selected_pass=${e.selected_pass} pass_n=${i.pass_n} recordlen=${i.record.length}`);return}if(this.table.rows.length<l.length){console.log(`table update create_rows ${this.table.rows.length} to ${l.length}`),this.table.tBodies.length==0&&this.table.createTBody();const d=Array(1+e.pass_range*2).fill("0").join("<br/>");console.log(`table update create_rows celltext_empty=${d}`);for(var h="",u=this.table.rows.length;u<l.length;u++)h+="<tr><th>"+u.toString()+"</th><td>"+d+`</td></tr>
`;this.table.tBodies[0].innerHTML+=h,console.log("table update create_rows trigger"),this.table.rows[0].cells[1].innerHTML=d,console.log("table update create_rows done")}if(!this.row_height){console.log("table update get first cell");const d=this.table.rows[0].cells[1];console.log("table update get first cell style");const n=window.getComputedStyle(d);console.log("table update calculate row_height"),this.row_height=Number(n.height.replace("px",""))+Number(n.paddingTop.replace("px",""))+Number(n.paddingBottom.replace("px","")),console.log(`WGSL_debug_table setting row_height=${this.row_height}`)}const b=this.scroll.scrollTop,p=[b,b+this.scroll.clientHeight],S=[Math.floor(p[0]/this.row_height),Math.min(Math.ceil(p[1]/this.row_height)+1,l.length)];this.processed[this.conf.selected_pass-1]||(l.every(d=>{if(this.debug.hang_detect("table update process_pass"))return!1;var n=0;return d.forEach(r=>{if(!r.processed){var T=r.value.toString().length+B.COL_WIDTH_ADJUST;this.conf.pass_range>0&&(T+=2);for(var m=n;;m++){if(m==this.col.length){var U=document.createElement("th");r.mark!=c.BUF_ENTRY_MARK_UNSET?i.marks[r.mark]?U.innerText=i.marks[r.mark]:U.innerText=r.mark.toString():U.innerText="d"+n.toString(),f.insertBefore(U,f.children[n].nextSibling);const A={maxlen:T,mark:r.mark,dirty_maxlen:!0,width:0};this.col.splice(n,0,A);break}if(this.col[m].mark==r.mark){n=m;break}}T>this.col[n].maxlen&&(this.col[n].maxlen=T,this.col[n].dirty_maxlen=!0),n++,r.processed=!0}}),!0}),this.processed[this.conf.selected_pass-1]=!0);const E=[this.scroll.scrollLeft,this.scroll.scrollLeft+this.scroll.clientWidth];var v=0,g=[0,this.col.length];this.col.every((d,n)=>{if(this.debug.hang_detect("table update header columns",1))return!1;if(v<E[0]&&(g[0]=n),d.dirty_maxlen){const r=f.children[n+1],T=`min-width: ${d.maxlen}ex;`;r.setAttribute("style",T);const m=window.getComputedStyle(r);d.width=Number(m.width.replace("px",""))}return v+=d.width,v<E[1]&&(g[1]=n+1),!0});for(var o=S[0];o<S[1]&&!this.debug.hang_detect("table update content");o++){const d=l[o],n=this.table.rows[o];for(var _=0,a=g[0];a<g[1];a++){const r=d[a];if(!r)continue;for(;r.mark!=this.col[_].mark;)if(_++,_==this.col.length){console.warn(`WGSL_debug update html table content: did not find column mark for entry at uid=${o} entry_n=${a}`);return}for(;!n.cells[_+1];)n.insertCell(-1);const T=n.cells[_+1];var w="";if(e.pass_range==0)w=r.value.toString();else{const m=Math.max(e.pass_range,Math.min(e.selected_pass-1,i.record.length-1-e.pass_range)),U=m-e.pass_range,A=m+e.pass_range;for(var N=U;N<=A;N++){if(N==e.selected_pass-1)w+="*"+r.value+"*";else{const R=i.record[N];w+=R&&a<R[o].length?R[o][a].value:"-"}N<A&&(w+=`
`)}}T.innerText=w,_++}}}};let I=B;I.COL_WIDTH_ADJUST=3,I.MIN_UPDATE_INTERVAL=100,y.WGSL_debug_table=I,Object.defineProperties(y,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=wgsl-debug-table.umd.js.map
