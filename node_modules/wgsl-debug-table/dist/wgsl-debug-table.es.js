const _WGSL_debug = class {
  constructor(bindgroup_num, buf_unit_entries_count) {
    this.shader_active = () => `@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;

var<private> _dbg_unit: u32;

fn dbg_init(uid: u32) {
	/* initialize debug unit for this uid */
	_dbg_unit = ${_WGSL_debug.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;
	_dbg[_dbg_unit] = 0u; // entries count
}

fn dbg_32m(mark: i32, val: u32, vtype: i32) {
	/* limit entries count, but still store the total number of calls */
	var entry_count = _dbg[_dbg_unit];
	_dbg[_dbg_unit] = entry_count + 1u;
	if (entry_count == ${this.buf_unit_entries_count}u) {
		return;
	}

	/* store data in a new debug unit entry */
	var entry_off = _dbg_unit + 1u + entry_count * ${_WGSL_debug.BUF_ENTRY_SIZE}u;
	_dbg[entry_off] = u32(vtype);
	_dbg[entry_off + 1u] = val;
	_dbg[entry_off + 2u] = u32(mark);
}

fn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${_WGSL_debug.BUF_ENTRY_TYPE_U32}); }
fn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_I32}); }
fn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_F32}); }
fn dbg_32(val: u32, vtype: i32) { dbg_32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val, vtype); }
fn dbg_u32(val: u32) { dbg_u32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }
fn dbg_i32(val: i32) { dbg_i32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }
fn dbg_f32(val: f32) { dbg_f32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }`;
    this.buf_unit_size = () => _WGSL_debug.BUF_UNIT_HEADER_SIZE + this.buf_unit_entries_count * _WGSL_debug.BUF_ENTRY_SIZE;
    this.buf_unit_size_bytes = () => Uint32Array.BYTES_PER_ELEMENT * this.buf_unit_size();
    this.bindgroup_num = bindgroup_num;
    this.buf_unit_entries_count = buf_unit_entries_count === void 0 ? _WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT : buf_unit_entries_count;
    this.record = new Array();
    this.pass_n = 0;
  }
  set_output(output) {
    output.attach(this);
    this.output = output;
  }
  add_shader(src, active) {
    if (active) {
      if (src.search(/^[ \t]*dbg_init/m) < 0) {
        alert("your shader does not contain any dbg_init() call, debug will not work properly");
      }
    }
    var debug_src = active ? this.shader_active() : _WGSL_debug.SHADER_INACTIVE;
    this.marks = new Array();
    const dbgm_calls = src.matchAll(/^[ \t]*dbg_[uif]?32m[ \t]*\([ \t]*(?<value>[0-9]+)[^;]*;[ \t]*(\/\/|\/\*)(?<comment>.*)/mg);
    for (const call of dbgm_calls) {
      const value = Number(call.groups["value"]);
      const comment = call.groups["comment"].trim();
      this.marks[value] = comment;
    }
    console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`);
    return debug_src + "\n" + src;
  }
  setup(device, unit_count) {
    console.log("WGSL_debug setup");
    this.device = device;
    this.unit_count = unit_count;
    this.buf_size = _WGSL_debug.BUF_HEADER_SIZE_BYTES + unit_count * this.buf_unit_size_bytes();
    console.log(`WGSL_debug unit_count=${unit_count} buf_size=${this.buf_size}`);
    if (this.buf) {
      this.buf.destroy();
    }
    this.buf = device.createBuffer({
      size: this.buf_size,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
    });
    if (this.dstbuf) {
      this.dstbuf.destroy();
    }
    this.dstbuf = device.createBuffer({
      size: this.buf_size,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.record = new Array();
    this.pass_n = 0;
    if (this.output) {
      this.output.reset();
    } else {
      console.log(`WGSL_debug output format: <debug_header>
<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`);
    }
  }
  create_bindgroup(pipeline) {
    this.bindgroup = this.device.createBindGroup({
      layout: pipeline.getBindGroupLayout(this.bindgroup_num),
      entries: [{ binding: 0, resource: { buffer: this.buf } }]
    });
  }
  set_bindgroup(pass) {
    pass.setBindGroup(this.bindgroup_num, this.bindgroup);
  }
  fetch(cmd) {
    cmd.copyBufferToBuffer(this.buf, 0, this.dstbuf, 0, this.buf_size);
  }
  async process(cb_data) {
    await this.dstbuf.mapAsync(GPUMapMode.READ);
    const buf = this.dstbuf.getMappedRange();
    const buf_u32 = new Uint32Array(buf);
    const buf_i32 = new Int32Array(buf);
    const buf_f32 = new Float32Array(buf);
    var pass_data;
    this.hang_detect("reset");
    pass_data = Array.from(Array(this.unit_count), () => new Array());
    for (var uid = 0; uid < this.unit_count; uid += 1) {
      if (this.hang_detect("process")) {
        break;
      }
      const unit_off = _WGSL_debug.BUF_HEADER_SIZE + uid * this.buf_unit_size();
      const entry_count = buf_u32[unit_off];
      if (entry_count > 0) {
        if (entry_count > this.buf_unit_entries_count) {
          console.warn(`WGSL debug: ${entry_count} debug calls where made from unit_id=${uid}, but only the first ${this.buf_unit_entries_count} where recorded
Consider increasing buf_unit_entries_count.`);
        }
        for (var entry = 0; entry < Math.min(entry_count, this.buf_unit_entries_count); entry++) {
          const entry_off = unit_off + _WGSL_debug.BUF_UNIT_HEADER_SIZE + entry * _WGSL_debug.BUF_ENTRY_SIZE;
          const type = buf_u32[entry_off];
          var value = -1;
          if (type == _WGSL_debug.BUF_ENTRY_TYPE_U32) {
            value = buf_u32[entry_off + 1];
          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_I32) {
            value = buf_i32[entry_off + 1];
          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_F32) {
            value = buf_f32[entry_off + 1];
          }
          var mark = buf_u32[entry_off + 2];
          pass_data[uid].push({
            value,
            type,
            mark
          });
        }
      }
    }
    this.record.push(pass_data);
    var console_log = true;
    if (this.output) {
      console_log = false;
      this.output.update();
    }
    if (cb_data) {
      console_log = cb_data(this.pass_n, pass_data, this.record);
    }
    if (console_log) {
      console.log(`WGSL_debug ${buf_u32.slice(0, _WGSL_debug.BUF_HEADER_SIZE).toString()}`);
      var s = "";
      pass_data.forEach((entries, uid2) => {
        s += `${uid2} [${entries.length}] ${entries}
`;
      });
      console.log(s);
    }
    this.dstbuf.unmap();
    this.pass_n++;
  }
  clear_processed() {
    this.record.forEach((pass) => {
      pass.forEach((entries) => {
        entries.forEach((entry) => {
          entry.processed = false;
        });
      });
    });
  }
  hang_detect(current_op, resolution) {
    if (current_op != this.hang_detect_op) {
      this.hang_detect_op = current_op;
      this.hang_detect_start = Date.now();
      this.hang_detect_counter = 0;
      this.hang_detect_resolution = resolution ? resolution : _WGSL_debug.HANG_DETECT_RESOLUTION;
    } else {
      this.hang_detect_counter++;
      if (this.hang_detect_counter % this.hang_detect_resolution == 0) {
        const now = Date.now();
        if (now - this.hang_detect_start > _WGSL_debug.HANG_DETECT_LIMIT) {
          console.warn(`WGSL_debug hang detected in '${current_op}' after ${this.hang_detect_counter} iterations (${_WGSL_debug.HANG_DETECT_LIMIT}ms), interrupting operation`);
          this.hang_detect_op = null;
          return true;
        }
      }
    }
    return false;
  }
};
let WGSL_debug = _WGSL_debug;
WGSL_debug.BUF_HEADER_SIZE = 16;
WGSL_debug.BUF_HEADER_SIZE_BYTES = Uint32Array.BYTES_PER_ELEMENT * _WGSL_debug.BUF_HEADER_SIZE;
WGSL_debug.BUF_UNIT_HEADER_SIZE = 1;
WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT = 20;
WGSL_debug.BUF_ENTRY_SIZE = 3;
WGSL_debug.BUF_ENTRY_TYPE_U32 = 1;
WGSL_debug.BUF_ENTRY_TYPE_I32 = 2;
WGSL_debug.BUF_ENTRY_TYPE_F32 = 3;
WGSL_debug.BUF_ENTRY_MARK_UNSET = 999999;
WGSL_debug.HANG_DETECT_LIMIT = 500;
WGSL_debug.HANG_DETECT_RESOLUTION = 100;
WGSL_debug.SHADER_INACTIVE = `fn dbg_init(unit_id: u32) {}

fn dbg_u32(val: u32) {}
fn dbg_i32(val: i32) {}
fn dbg_f32(val: f32) {}
fn dbg_32(val: u32, vtype: u32) {}

fn dbg_u32m(mark: i32, val: u32) {}
fn dbg_i32m(mark: i32, val: i32) {}
fn dbg_f32m(mark: i32, val: f32) {}
fn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;
class WGSL_debug_output {
  constructor() {
  }
  attach(debug) {
    console.log("WGSL_debug output attach");
    this.debug = debug;
  }
}
const _WGSL_debug_table = class extends WGSL_debug_output {
  constructor(output_elm) {
    super();
    this.conf = {
      selected_pass: 0,
      pass_range: 0,
      live: false,
      dirty: false
    };
    const scroll_elm = output_elm + "-scroll";
    const table_elm = output_elm + "-table";
    const timeline_elm = output_elm + "-timeline";
    const timelineval_elm = output_elm + "-timelineval";
    const passcount_elm = output_elm + "-passcount";
    const timelinelive_elm = output_elm + "-timelinelive";
    const passrange_elm = output_elm + "-passrange";
    const elm = document.getElementById(output_elm);
    if (!elm) {
      console.warn(`WGSL_debug: could not find debug output element id : '${output_elm}`);
      return;
    }
    elm.innerHTML = `
<div class="debug-output-controls">
	pass&nbsp;&nbsp;
	<input type="number" min="1" max="0" value="0" step="1" id="${timelineval_elm}"/> &#xb1;
	<input type="number" min="0" max="60" value="0" step="1" id="${passrange_elm}"/> /
	<span id="${passcount_elm}"></span>
	<input type="range" min="1" max="0" value="0" step="1" id="${timeline_elm}" class="debug-output-timeline"/>
	<label><input type="checkbox" checked=1 id="${timelinelive_elm}" />live</label>
</div>
<div id="${scroll_elm}" class="debug-output-table">
	<table id="${table_elm}">
	</table>
<div>
`;
    this.scroll = document.getElementById(scroll_elm);
    this.table = document.getElementById(table_elm);
    this.timeline = document.getElementById(timeline_elm);
    this.timelineval = document.getElementById(timelineval_elm);
    this.passcount = document.getElementById(passcount_elm);
    this.timelinelive = document.getElementById(timelinelive_elm);
    this.passrange = document.getElementById(passrange_elm);
    const table_scroll = (_) => {
      this.update();
    };
    const timeline_input = (e) => {
      this.conf.selected_pass = Number(e.target.value);
      this.conf.live = false;
      this.update();
    };
    const timelineval_input = (e) => {
      this.conf.selected_pass = Number(e.target.value);
      this.conf.live = false;
      this.update();
    };
    const timelinelive_click = (e) => {
      this.conf.live = e.target.checked;
      this.update();
    };
    const passrange_input = (e) => {
      this.conf.pass_range = Number(e.target.value);
      this.row_height = 0;
      this.debug.clear_processed();
      this.reset();
      this.update();
    };
    this.scroll.addEventListener("scroll", table_scroll);
    this.timeline.addEventListener("input", timeline_input);
    this.timelineval.addEventListener("input", timelineval_input);
    this.timelinelive.addEventListener("click", timelinelive_click);
    this.passrange.addEventListener("input", passrange_input);
    var style = document.createElement("style");
    style.innerHTML = `
#${timelineval_elm} { width: 5em; }
#${passrange_elm} { width: 3em; }
`;
    document.head.appendChild(style);
    this.row_height = 0;
    this.reset();
  }
  reset() {
    if (!this.table) {
      return;
    }
    this.col = new Array();
    this.processed = new Array();
    this.conf.selected_pass = 0;
    this.conf.live = true;
    this._reset_table();
    this.update();
  }
  _reset_table() {
    this.table.innerHTML = "";
    var rowh = this.table.createTHead();
    var cellh = document.createElement("th");
    cellh.innerText = `uid`;
    rowh.appendChild(cellh);
  }
  update() {
    if (!this.table || !this.debug) {
      return;
    }
    while (this.processed.length < this.debug.record.length) {
      this.processed.push(false);
    }
    if (window.getComputedStyle(this.table).visibility == "hidden") {
      return;
    }
    const now = Date.now();
    if (this.update_timeout || this.last_update && now - this.last_update < _WGSL_debug_table.MIN_UPDATE_INTERVAL) {
      if (!this.update_timeout) {
        this.update_timeout = setTimeout(() => {
          this.update_timeout = null;
          this.last_update = null;
          this.update();
        }, _WGSL_debug_table.MIN_UPDATE_INTERVAL);
      }
      return;
    }
    this.debug.hang_detect("reset");
    this.last_update = now;
    const conf = this.conf;
    const debug = this.debug;
    const thead = this.table.tHead;
    if (conf.live == true) {
      conf.selected_pass = debug.pass_n;
    }
    this.timelineval.max = debug.pass_n.toString();
    this.timelineval.value = conf.selected_pass.toString();
    this.passcount.innerText = debug.pass_n.toString();
    this.timeline.max = debug.pass_n.toString();
    this.timeline.value = conf.selected_pass.toString();
    this.timelinelive.checked = conf.live;
    const pass = debug.record[conf.selected_pass - 1];
    if (!pass) {
      console.log(`table update no pass selected_pass=${conf.selected_pass} pass_n=${debug.pass_n} recordlen=${debug.record.length}`);
      return;
    }
    if (this.table.rows.length < pass.length) {
      console.log(`table update create_rows ${this.table.rows.length} to ${pass.length}`);
      if (this.table.tBodies.length == 0) {
        this.table.createTBody();
      }
      const celltext_empty = Array(1 + conf.pass_range * 2).fill("0").join("<br/>");
      console.log(`table update create_rows celltext_empty=${celltext_empty}`);
      var rows = "";
      for (var n = this.table.rows.length; n < pass.length; n++) {
        rows += "<tr><th>" + n.toString() + "</th><td>" + celltext_empty + "</td></tr>\n";
      }
      this.table.tBodies[0].innerHTML += rows;
      console.log(`table update create_rows trigger`);
      this.table.rows[0].cells[1].innerHTML = celltext_empty;
      console.log(`table update create_rows done`);
    }
    if (!this.row_height) {
      console.log("table update get first cell");
      const firstcell = this.table.rows[0].cells[1];
      console.log("table update get first cell style");
      const style = window.getComputedStyle(firstcell);
      console.log("table update calculate row_height");
      this.row_height = Number(style.height.replace("px", "")) + Number(style.paddingTop.replace("px", "")) + Number(style.paddingBottom.replace("px", ""));
      console.log(`WGSL_debug_table setting row_height=${this.row_height}`);
    }
    const scrolltop = this.scroll.scrollTop;
    const table_y_visible = [
      scrolltop,
      scrolltop + this.scroll.clientHeight
    ];
    const row_visible = [
      Math.floor(table_y_visible[0] / this.row_height),
      Math.min(Math.ceil(table_y_visible[1] / this.row_height) + 1, pass.length)
    ];
    if (!this.processed[this.conf.selected_pass - 1]) {
      pass.every((entries) => {
        if (this.debug.hang_detect("table update process_pass")) {
          return false;
        }
        var col_n2 = 0;
        entries.forEach((entry) => {
          if (entry.processed) {
            return;
          }
          var len = entry.value.toString().length + _WGSL_debug_table.COL_WIDTH_ADJUST;
          if (this.conf.pass_range > 0) {
            len += 2;
          }
          for (var col_ins = col_n2; ; col_ins++) {
            if (col_ins == this.col.length) {
              var cellh = document.createElement("th");
              if (entry.mark != WGSL_debug.BUF_ENTRY_MARK_UNSET) {
                if (debug.marks[entry.mark]) {
                  cellh.innerText = debug.marks[entry.mark];
                } else {
                  cellh.innerText = entry.mark.toString();
                }
              } else {
                cellh.innerText = "d" + col_n2.toString();
              }
              thead.insertBefore(cellh, thead.children[col_n2].nextSibling);
              const col = {
                maxlen: len,
                mark: entry.mark,
                dirty_maxlen: true,
                width: 0
              };
              this.col.splice(col_n2, 0, col);
              break;
            }
            if (this.col[col_ins].mark == entry.mark) {
              col_n2 = col_ins;
              break;
            }
          }
          if (len > this.col[col_n2].maxlen) {
            this.col[col_n2].maxlen = len;
            this.col[col_n2].dirty_maxlen = true;
          }
          col_n2++;
          entry.processed = true;
        });
        return true;
      });
      this.processed[this.conf.selected_pass - 1] = true;
    }
    const table_x_visible = [
      this.scroll.scrollLeft,
      this.scroll.scrollLeft + this.scroll.clientWidth
    ];
    var col_offsetx = 0;
    var col_visible = [0, this.col.length];
    this.col.every((col, col_n2) => {
      if (this.debug.hang_detect("table update header columns", 1)) {
        return false;
      }
      if (col_offsetx < table_x_visible[0]) {
        col_visible[0] = col_n2;
      }
      if (col.dirty_maxlen) {
        const cellh = thead.children[col_n2 + 1];
        const s2 = `min-width: ${col.maxlen}ex;`;
        cellh.setAttribute("style", s2);
        const style = window.getComputedStyle(cellh);
        col.width = Number(style.width.replace("px", ""));
      }
      col_offsetx += col.width;
      if (col_offsetx < table_x_visible[1]) {
        col_visible[1] = col_n2 + 1;
      }
      return true;
    });
    for (var uid = row_visible[0]; uid < row_visible[1]; uid++) {
      if (this.debug.hang_detect("table update content")) {
        break;
      }
      const entries = pass[uid];
      const row = this.table.rows[uid];
      var col_n = 0;
      for (var entry_n = col_visible[0]; entry_n < col_visible[1]; entry_n++) {
        const entry = entries[entry_n];
        if (!entry) {
          continue;
        }
        while (entry.mark != this.col[col_n].mark) {
          col_n++;
          if (col_n == this.col.length) {
            console.warn(`WGSL_debug update html table content: did not find column mark for entry at uid=${uid} entry_n=${entry_n}`);
            return;
          }
        }
        while (!row.cells[col_n + 1]) {
          row.insertCell(-1);
        }
        const cell = row.cells[col_n + 1];
        var s = "";
        if (conf.pass_range == 0) {
          s = entry.value.toString();
        } else {
          const ctx_center = Math.max(conf.pass_range, Math.min(conf.selected_pass - 1, debug.record.length - 1 - conf.pass_range));
          const ctx_first = ctx_center - conf.pass_range;
          const ctx_last = ctx_center + conf.pass_range;
          for (var ctx_n = ctx_first; ctx_n <= ctx_last; ctx_n++) {
            if (ctx_n == conf.selected_pass - 1) {
              s += "*" + entry.value + "*";
            } else {
              const ctx_pass = debug.record[ctx_n];
              s += ctx_pass && entry_n < ctx_pass[uid].length ? ctx_pass[uid][entry_n].value : "-";
            }
            if (ctx_n < ctx_last) {
              s += "\n";
            }
          }
        }
        cell.innerText = s;
        col_n++;
      }
    }
  }
};
let WGSL_debug_table = _WGSL_debug_table;
WGSL_debug_table.COL_WIDTH_ADJUST = 3;
WGSL_debug_table.MIN_UPDATE_INTERVAL = 100;
export { WGSL_debug_table };
//# sourceMappingURL=wgsl-debug-table.es.js.map
